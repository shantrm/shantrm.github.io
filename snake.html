<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <link rel="icon" type="image/png" href="icon.png">
    <link rel="stylesheet" href="style.css">
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: black;
        }

        #gameContainer {
            text-align: center;
        }

        canvas {
            border: 2px solid white;
            display: block;
            margin: 20px auto;
            cursor: pointer;
        }

        .back-link {
            display: block;
            margin-top: 20px;
            color: white;
            text-decoration: none;
            font-family: 'Courier New', monospace;
        }

        .back-link:hover {
            text-decoration: underline;
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="608" height="480"></canvas>
        <a href="index.html" class="back-link">‚Üê Back to Home</a>
    </div>

    <!-- Load configuration and API helpers -->
    <script src="config.js"></script>
    <script src="api-helpers.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Colors matching Python version
        const BLACK = '#000000';
        const RED = '#FF0000';
        const ORANGE = '#FFA500';
        const YELLOW = '#E1FF00';
        const GREEN = '#00FF00';
        const DARKGREEN = '#008000';
        const BLUE = '#0000FF';
        const GRAY = '#C8C8C8';
        const WHITE = '#FFFFFF';
        const PURPLE = '#FF00FF';
        const RAINBOW = 'RAINBOW'; // Special value for rainbow mode

        // Rainbow colors array
        const RAINBOW_COLORS = [RED, ORANGE, YELLOW, GREEN, BLUE, PURPLE];

        // Game settings
        let snakeColor = YELLOW;
        let speed = 30;
        let currentScreen = 'start';
        let score = 0;
        let snakeList = [];
        let snakeLength = 1;
        let snakeX = 304;
        let snakeY = 240;
        let snakeXChange = 0;
        let snakeYChange = 0;
        let direction = 100;
        let foodX = 0;
        let foodY = 0;
        let gameInterval = null;
        let usernameInput = '';
        let scoreSubmitted = false;

        // Highscore data (loaded from API)
        let userList = [];
        let scoreList = [];
        let scoreScrollIndex = 0; // Current scroll position for highscores
        const SCORES_PER_PAGE = 5; // Number of scores to show at once
        const MAX_HIGHSCORES = 50; // Maximum number of highscores to keep
        let isLoadingScores = false;
        let scoresLoadError = null;

        // Check if rainbow skin is unlocked
        function isRainbowUnlocked() {
            const unlocked = localStorage.getItem('snakeRainbowUnlocked');
            return unlocked === 'true';
        }

        // Unlock rainbow skin
        function unlockRainbow() {
            localStorage.setItem('snakeRainbowUnlocked', 'true');
        }

        // Load highscores from API
        async function loadHighscores() {
            isLoadingScores = true;
            scoresLoadError = null;

            try {
                const scores = await getTopScores(MAX_HIGHSCORES);

                // Convert API response to local format
                userList = scores.map(s => s.username);
                scoreList = scores.map(s => s.score);

                // If no scores, initialize with empty arrays (no default score)
                if (userList.length === 0) {
                    userList = [];
                    scoreList = [];
                }
            } catch (error) {
                console.error('Failed to load highscores:', error);
                scoresLoadError = error.message;
                // Keep empty arrays on error
                userList = [];
                scoreList = [];
            } finally {
                isLoadingScores = false;
            }
        }

        // Button class (matching Python button class)
        class Button {
            constructor(color, x, y, width, height, text = '') {
                this.color = color;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.text = text;
                this.hoverColor = color;
            }

            draw() {
                // Draw button
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeStyle = BLACK;
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);

                // Draw text
                if (this.text) {
                    // Use larger font for title
                    if (this.text === 'Snake Game!') {
                        ctx.fillStyle = WHITE;
                        ctx.font = 'bold 72px Arial';
                    } else {
                        ctx.fillStyle = BLACK;
                        ctx.font = 'bold 45px Arial';
                    }
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.text, this.x + this.width / 2, this.y + this.height / 2);
                }
            }

            isOver(mouseX, mouseY) {
                return mouseX > this.x && mouseX < this.x + this.width &&
                    mouseY > this.y && mouseY < this.y + this.height;
            }
        }

        // Buttons for different screens
        let titleButton = new Button(RED, 70, 70, 475, 80, 'Snake Game!');
        let startButton = new Button(GREEN, 320, 225, 250, 100, 'Start');
        let scoreButton = new Button(YELLOW, 40, 225, 250, 100, 'Highscore');
        let settingButton = new Button(BLACK, 0, 360, 121, 118, '');
        let backButton = new Button(GRAY, 483, 430, 125, 50, 'Back');
        let homeButton = new Button(GRAY, 483, 430, 125, 50, 'Home');
        let retryButton = new Button(GRAY, 0, 430, 125, 50, 'Retry');
        let submitButton = new Button(GREEN, 230, 322, 160, 50, 'Submit');

        // Color buttons for settings (centered - 7 buttons, 50px each, 18px spacing)
        let redBtn = new Button(RED, 75, 120, 50, 50, '');
        let orangeBtn = new Button(ORANGE, 143, 120, 50, 50, '');
        let yellowBtn = new Button(YELLOW, 211, 120, 50, 50, '');
        let greenBtn = new Button(GREEN, 279, 120, 50, 50, '');
        let blueBtn = new Button(BLUE, 347, 120, 50, 50, '');
        let purpleBtn = new Button(PURPLE, 415, 120, 50, 50, '');
        let rainbowBtn = new Button(GRAY, 483, 120, 50, 50, '');

        // Speed buttons
        let moreBtn = new Button(WHITE, 385, 300, 50, 50, '+');
        let lessBtn = new Button(WHITE, 168, 300, 50, 50, '-');

        // Arrow buttons for highscore scrolling
        let upArrowBtn = new Button(GRAY, 500, 150, 50, 50, '‚ñ≤');
        let downArrowBtn = new Button(GRAY, 500, 340, 50, 50, '‚ñº');

        // Initialize game
        async function init() {
            drawStartScreen();

            // Preload profanity wordlist (async, don't block UI)
            loadProfanityWords().catch(err => {
                console.error('Failed to preload profanity wordlist:', err);
            });

            // Load highscores from API (async, but don't block UI)
            loadHighscores().catch(err => {
                console.error('Failed to load initial highscores:', err);
            });

            // Mouse event listeners
            canvas.addEventListener('click', handleClick);
            canvas.addEventListener('mousemove', handleMouseMove);

            // Keyboard event listeners
            document.addEventListener('keydown', handleKeyDown);
        }

        // Handle mouse clicks
        function handleClick(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (currentScreen === 'start') {
                if (startButton.isOver(mouseX, mouseY)) {
                    startGame();
                } else if (scoreButton.isOver(mouseX, mouseY)) {
                    showScoreScreen();
                } else if (settingButton.isOver(mouseX, mouseY)) {
                    showSettingsScreen();
                }
            } else if (currentScreen === 'score') {
                if (backButton.isOver(mouseX, mouseY)) {
                    drawStartScreen();
                } else if (upArrowBtn.isOver(mouseX, mouseY)) {
                    if (scoreScrollIndex > 0) {
                        scoreScrollIndex -= SCORES_PER_PAGE;
                        if (scoreScrollIndex < 0) scoreScrollIndex = 0;
                        showScoreScreen(false); // Don't reload from API on scroll
                    }
                } else if (downArrowBtn.isOver(mouseX, mouseY)) {
                    const combined = userList.map((user, i) => ({ user, score: scoreList[i] }));
                    combined.sort((a, b) => b.score - a.score);
                    const maxScroll = Math.max(0, combined.length - SCORES_PER_PAGE);
                    if (scoreScrollIndex < maxScroll) {
                        scoreScrollIndex += SCORES_PER_PAGE;
                        if (scoreScrollIndex > maxScroll) scoreScrollIndex = maxScroll;
                        showScoreScreen(false); // Don't reload from API on scroll
                    }
                }
            } else if (currentScreen === 'settings') {
                if (backButton.isOver(mouseX, mouseY)) {
                    drawStartScreen();
                } else if (redBtn.isOver(mouseX, mouseY)) {
                    snakeColor = RED;
                    showSettingsScreen();
                } else if (orangeBtn.isOver(mouseX, mouseY)) {
                    snakeColor = ORANGE;
                    showSettingsScreen();
                } else if (yellowBtn.isOver(mouseX, mouseY)) {
                    snakeColor = YELLOW;
                    showSettingsScreen();
                } else if (greenBtn.isOver(mouseX, mouseY)) {
                    snakeColor = GREEN;
                    showSettingsScreen();
                } else if (blueBtn.isOver(mouseX, mouseY)) {
                    snakeColor = BLUE;
                    showSettingsScreen();
                } else if (purpleBtn.isOver(mouseX, mouseY)) {
                    snakeColor = PURPLE;
                    showSettingsScreen();
                } else if (rainbowBtn.isOver(mouseX, mouseY) && isRainbowUnlocked()) {
                    snakeColor = RAINBOW;
                    showSettingsScreen();
                } else if (moreBtn.isOver(mouseX, mouseY)) {
                    if (speed === 90) {
                        // Max speed
                    } else if (speed === 15) {
                        speed = 30;
                    } else {
                        speed += 30;
                    }
                    showSettingsScreen();
                } else if (lessBtn.isOver(mouseX, mouseY)) {
                    if (speed === 30) {
                        speed = 15;
                    } else if (speed === 15) {
                        // Min speed
                    } else {
                        speed -= 30;
                    }
                    showSettingsScreen();
                }
            } else if (currentScreen === 'gameover') {
                if (homeButton.isOver(mouseX, mouseY)) {
                    drawStartScreen();
                } else if (retryButton.isOver(mouseX, mouseY)) {
                    startGame();
                } else if (submitButton.isOver(mouseX, mouseY) && !scoreSubmitted && usernameInput.trim() !== '') {
                    submitScoreToAPI();
                }
            }
        }

        // Handle mouse movement for hover effects
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (currentScreen === 'start') {
                let newStartColor = startButton.isOver(mouseX, mouseY) ? RED : GREEN;
                let newScoreColor = scoreButton.isOver(mouseX, mouseY) ? BLUE : YELLOW;

                // Only redraw if colors changed
                if (startButton.color !== newStartColor || scoreButton.color !== newScoreColor) {
                    startButton.color = newStartColor;
                    scoreButton.color = newScoreColor;

                    // Clear and redraw only the buttons
                    ctx.fillStyle = BLACK;
                    ctx.fillRect(startButton.x, startButton.y, startButton.width, startButton.height);
                    ctx.fillRect(scoreButton.x, scoreButton.y, scoreButton.width, scoreButton.height);

                    startButton.draw();
                    scoreButton.draw();
                }
            } else if (currentScreen === 'score') {
                let newBackColor = backButton.isOver(mouseX, mouseY) ? WHITE : GRAY;
                let newUpArrowColor = upArrowBtn.isOver(mouseX, mouseY) ? WHITE : GRAY;
                let newDownArrowColor = downArrowBtn.isOver(mouseX, mouseY) ? WHITE : GRAY;

                const combined = userList.map((user, i) => ({ user, score: scoreList[i] }));
                combined.sort((a, b) => b.score - a.score);
                const maxScroll = Math.max(0, combined.length - SCORES_PER_PAGE);

                // Only show hover if arrow is visible
                if (scoreScrollIndex <= 0) newUpArrowColor = GRAY;
                if (scoreScrollIndex >= maxScroll) newDownArrowColor = GRAY;

                if (backButton.color !== newBackColor || upArrowBtn.color !== newUpArrowColor || downArrowBtn.color !== newDownArrowColor) {
                    backButton.color = newBackColor;
                    upArrowBtn.color = newUpArrowColor;
                    downArrowBtn.color = newDownArrowColor;

                    ctx.fillStyle = BLACK;
                    ctx.fillRect(backButton.x, backButton.y, backButton.width, backButton.height);
                    if (scoreScrollIndex > 0) {
                        ctx.fillRect(upArrowBtn.x, upArrowBtn.y, upArrowBtn.width, upArrowBtn.height);
                    }
                    if (scoreScrollIndex < maxScroll) {
                        ctx.fillRect(downArrowBtn.x, downArrowBtn.y, downArrowBtn.width, downArrowBtn.height);
                    }

                    backButton.draw();
                    if (scoreScrollIndex > 0) upArrowBtn.draw();
                    if (scoreScrollIndex < maxScroll) downArrowBtn.draw();
                }
            } else if (currentScreen === 'settings') {
                let newBackColor = backButton.isOver(mouseX, mouseY) ? WHITE : GRAY;
                let newMoreColor = moreBtn.isOver(mouseX, mouseY) ? GRAY : WHITE;
                let newLessColor = lessBtn.isOver(mouseX, mouseY) ? GRAY : WHITE;

                if (backButton.color !== newBackColor || moreBtn.color !== newMoreColor || lessBtn.color !== newLessColor) {
                    backButton.color = newBackColor;
                    moreBtn.color = newMoreColor;
                    lessBtn.color = newLessColor;

                    // Clear button areas
                    ctx.fillStyle = BLACK;
                    ctx.fillRect(moreBtn.x, moreBtn.y, moreBtn.width, moreBtn.height);
                    ctx.fillRect(lessBtn.x, lessBtn.y, lessBtn.width, lessBtn.height);
                    ctx.fillRect(backButton.x, backButton.y, backButton.width, backButton.height);

                    moreBtn.draw();
                    lessBtn.draw();
                    backButton.draw();
                }
            } else if (currentScreen === 'gameover') {
                let newHomeColor = homeButton.isOver(mouseX, mouseY) ? WHITE : GRAY;
                let newRetryColor = retryButton.isOver(mouseX, mouseY) ? WHITE : GRAY;

                if (homeButton.color !== newHomeColor || retryButton.color !== newRetryColor) {
                    homeButton.color = newHomeColor;
                    retryButton.color = newRetryColor;

                    // Clear button areas
                    ctx.fillStyle = BLACK;
                    ctx.fillRect(homeButton.x, homeButton.y, homeButton.width, homeButton.height);
                    ctx.fillRect(retryButton.x, retryButton.y, retryButton.width, retryButton.height);

                    homeButton.draw();
                    retryButton.draw();
                }
            }
        }

        // Handle keyboard input
        function handleKeyDown(e) {
            if (currentScreen === 'game') {
                if (e.key === 'ArrowLeft' && direction !== 1) {
                    direction = 3;
                    snakeXChange = -10;
                    snakeYChange = 0;
                } else if (e.key === 'ArrowRight' && direction !== 3) {
                    direction = 1;
                    snakeXChange = 10;
                    snakeYChange = 0;
                } else if (e.key === 'ArrowUp' && direction !== 4) {
                    direction = 2;
                    snakeYChange = -10;
                    snakeXChange = 0;
                } else if (e.key === 'ArrowDown' && direction !== 2) {
                    direction = 4;
                    snakeYChange = 10;
                    snakeXChange = 0;
                }
            } else if (currentScreen === 'gameover') {
                if (e.key === 'Backspace') {
                    usernameInput = usernameInput.slice(0, -1);
                    drawGameOverScreen();
                } else if (e.key.length === 1 && usernameInput.length < 20) { // Increased to 20 to match DB limit
                    // Only allow alphanumeric, spaces, hyphens, underscores
                    const char = e.key;
                    if (/^[a-zA-Z0-9\s\-_]$/.test(char)) {
                        usernameInput += char;
                        drawGameOverScreen();
                    }
                }
            }
        }

        // Draw settings icon (simple gear)
        function drawSettingsIcon() {
            ctx.fillStyle = GRAY;
            ctx.font = 'bold 80px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚öô', 60, 419);
        }

        // Draw start screen
        function drawStartScreen() {
            currentScreen = 'start';
            ctx.fillStyle = BLACK;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title button
            titleButton.draw();

            // Buttons
            startButton.draw();
            scoreButton.draw();
            settingButton.draw();
            drawSettingsIcon();
        }

        // Show settings screen
        function showSettingsScreen() {
            currentScreen = 'settings';
            ctx.fillStyle = BLACK;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title for colors
            ctx.fillStyle = WHITE;
            ctx.font = 'bold 50px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Colors!', 304, 60);

            // Title for speed
            ctx.fillText('Speed!', 304, 260);

            // Speed number
            let speedNum = speed / 30;
            if (speed === 15) speedNum = 0.5;
            ctx.fillText(speedNum.toString(), 304, 340);

            // Draw color buttons
            redBtn.draw();
            orangeBtn.draw();
            yellowBtn.draw();
            greenBtn.draw();
            blueBtn.draw();
            purpleBtn.draw();

            // Draw rainbow button if unlocked
            if (isRainbowUnlocked()) {
                // Draw rainbow gradient effect for the button
                const gradient = ctx.createLinearGradient(483, 120, 533, 170);
                gradient.addColorStop(0, RED);
                gradient.addColorStop(0.2, ORANGE);
                gradient.addColorStop(0.4, YELLOW);
                gradient.addColorStop(0.6, GREEN);
                gradient.addColorStop(0.8, BLUE);
                gradient.addColorStop(1, PURPLE);
                ctx.fillStyle = gradient;
                ctx.fillRect(483, 120, 50, 50);
                ctx.strokeStyle = BLACK;
                ctx.lineWidth = 2;
                ctx.strokeRect(483, 120, 50, 50);
            } else {
                // Draw locked rainbow button
                rainbowBtn.color = DARKGREEN;
                rainbowBtn.draw();
                // Draw lock symbol
                ctx.fillStyle = WHITE;
                ctx.font = 'bold 30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üîí', 508, 150);
            }

            // Highlight selected color
            let selectX, selectY;
            if (snakeColor === RED) { selectX = 70; selectY = 115; }
            else if (snakeColor === ORANGE) { selectX = 138; selectY = 115; }
            else if (snakeColor === YELLOW) { selectX = 206; selectY = 115; }
            else if (snakeColor === GREEN) { selectX = 274; selectY = 115; }
            else if (snakeColor === BLUE) { selectX = 342; selectY = 115; }
            else if (snakeColor === PURPLE) { selectX = 410; selectY = 115; }
            else if (snakeColor === RAINBOW) { selectX = 478; selectY = 115; }

            ctx.strokeStyle = WHITE;
            ctx.lineWidth = 5;
            ctx.strokeRect(selectX, selectY, 60, 60);

            // Speed buttons
            moreBtn.draw();
            lessBtn.draw();

            // Back button
            backButton.draw();
        }

        // Show score screen
        async function showScoreScreen(reloadFromAPI = true) {
            currentScreen = 'score';
            ctx.fillStyle = BLACK;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Reload scores from API only if requested (not on scroll)
            if (reloadFromAPI) {
                await loadHighscores();
            }

            // Combine and sort (already sorted by API, but ensure consistency)
            let combined = userList.map((user, i) => ({ user, score: scoreList[i] }));
            combined.sort((a, b) => b.score - a.score);
            combined = combined.slice(0, MAX_HIGHSCORES); // Limit to 50

            // Reset scroll if out of bounds
            const maxScroll = Math.max(0, combined.length - SCORES_PER_PAGE);
            if (scoreScrollIndex > maxScroll) {
                scoreScrollIndex = maxScroll;
            }

            // Title
            ctx.fillStyle = BLUE;
            ctx.fillRect(90, 50, 430, 80);
            ctx.fillStyle = WHITE;
            ctx.font = 'bold 72px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Highscores:', 100, 105);

            // Show loading or error message
            if (isLoadingScores) {
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Loading scores...', 304, 240);
                backButton.draw();
                return;
            }

            if (scoresLoadError) {
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = RED;
                ctx.fillText('Failed to load scores', 304, 220);
                ctx.fillStyle = WHITE;
                ctx.font = '18px Arial';
                ctx.fillText('Check your connection', 304, 250);
                backButton.draw();
                return;
            }

            // Display paginated scores
            if (combined.length === 0) {
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No scores yet!', 304, 240);
                ctx.fillText('Be the first!', 304, 280);
            } else {
                ctx.font = '30px Arial';
                ctx.textAlign = 'left';
                let y = 160;
                const startIndex = scoreScrollIndex;
                const endIndex = Math.min(startIndex + SCORES_PER_PAGE, combined.length);

                for (let i = startIndex; i < endIndex; i++) {
                    const rank = i + 1;
                    ctx.fillText(rank + '. ' + combined[i].user, 114, y);
                    ctx.fillText(combined[i].score.toString(), 430, y);
                    y += 40;
                }

                // Draw arrow buttons if there are more scores to scroll
                if (combined.length > SCORES_PER_PAGE) {
                    // Up arrow (only show if not at top)
                    if (scoreScrollIndex > 0) {
                        upArrowBtn.draw();
                    }

                    // Down arrow (only show if not at bottom)
                    if (scoreScrollIndex < maxScroll) {
                        downArrowBtn.draw();
                    }
                }
            }

            backButton.draw();
        }

        // Start the game
        function startGame() {
            currentScreen = 'game';
            score = 0;
            snakeList = [];
            snakeLength = 1;
            snakeX = 350;
            snakeY = 290;
            snakeXChange = 0;
            snakeYChange = 0;
            direction = 100;

            // Random food position
            foodX = Math.floor(Math.random() * (608 - 20));
            foodY = Math.floor(Math.random() * (480 - 20));

            // Start game loop
            if (gameInterval) clearInterval(gameInterval);
            gameInterval = setInterval(gameLoop, 1000 / speed);
        }

        // Game loop
        function gameLoop() {
            // Check wall collision
            if (snakeX >= 608 || snakeX < 0 || snakeY >= 480 || snakeY < 0) {
                gameOver();
                return;
            }

            // Update position
            snakeX += snakeXChange;
            snakeY += snakeYChange;

            // Calculate multiplier based on speed
            let multiplier = 1;
            if (speed === 60) multiplier = 2;
            else if (speed === 90) multiplier = 3;

            // Food color (opposite of snake)
            let foodColor = snakeColor === RED ? YELLOW : RED;

            // Draw
            ctx.fillStyle = BLACK;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Score
            ctx.fillStyle = WHITE;
            ctx.font = '30px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Score: ' + score, 10, 35);

            // Multiplier
            ctx.textAlign = 'right';
            ctx.fillText('Multiplier (' + multiplier + 'x)', 598, 35);

            // Food
            ctx.fillStyle = foodColor;
            ctx.fillRect(foodX, foodY, 20, 20);

            // Snake
            let segment = [snakeX, snakeY];
            snakeList.push(segment);

            if (snakeList.length > snakeLength) {
                snakeList.shift();
            }

            // Check self collision
            for (let i = 0; i < snakeList.length - 1; i++) {
                if (snakeList[i][0] === snakeX && snakeList[i][1] === snakeY) {
                    gameOver();
                    return;
                }
            }

            // Draw snake
            if (snakeColor === RAINBOW) {
                // Draw each segment in rainbow colors
                for (let i = 0; i < snakeList.length; i++) {
                    const colorIndex = i % RAINBOW_COLORS.length;
                    ctx.fillStyle = RAINBOW_COLORS[colorIndex];
                    ctx.fillRect(snakeList[i][0], snakeList[i][1], 20, 20);
                }
            } else {
                ctx.fillStyle = snakeColor;
                for (let segment of snakeList) {
                    ctx.fillRect(segment[0], segment[1], 20, 20);
                }
            }

            // Check food collision
            if (Math.abs(snakeX - foodX) < 20 && Math.abs(snakeY - foodY) < 20) {
                score += (1 * multiplier);
                foodX = Math.floor(Math.random() * (608 - 20));
                foodY = Math.floor(Math.random() * (480 - 20));
                snakeLength += 2;
            }
        }

        // Game over
        function gameOver() {
            if (gameInterval) clearInterval(gameInterval);
            currentScreen = 'gameover';
            usernameInput = '';
            scoreSubmitted = false;

            // Unlock rainbow skin if score >= 20
            let justUnlocked = false;
            if (score >= 20 && !isRainbowUnlocked()) {
                unlockRainbow();
                justUnlocked = true;
            }

            drawGameOverScreen(justUnlocked);
        }

        // Draw game over screen
        function drawGameOverScreen(justUnlocked = false) {
            ctx.fillStyle = BLACK;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title
            ctx.fillStyle = PURPLE;
            ctx.fillRect(95, 50, 420, 80);
            ctx.fillStyle = WHITE;
            ctx.font = 'bold 72px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Game Over!', 304, 105);

            // Score
            ctx.font = '30px Arial';
            ctx.fillText('Score: ' + score, 304, 180);

            // Show unlock message if rainbow was just unlocked
            if (justUnlocked) {
                ctx.fillStyle = YELLOW;
                ctx.font = 'bold 24px Arial';
                ctx.fillText('New skin unlocked!', 304, 210);
                ctx.fillStyle = WHITE;
            }

            // Username prompt
            ctx.font = '30px Arial';
            ctx.fillText('Username (3-20 chars):', 304, 240);

            // Input box (centered)
            const inputBoxWidth = 230;
            const inputBoxX = (canvas.width - inputBoxWidth) / 2;
            ctx.fillStyle = WHITE;
            ctx.fillRect(inputBoxX, 265, inputBoxWidth, 32);
            ctx.fillStyle = BLACK;
            ctx.font = '20px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(usernameInput, inputBoxX + 5, 285);

            // Show character count
            ctx.fillStyle = WHITE;
            ctx.font = '16px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(`${usernameInput.length}/20`, inputBoxX + inputBoxWidth - 5, 310);

            // Submit button (centered)
            submitButton.color = scoreSubmitted ? DARKGREEN : GREEN;
            submitButton.x = (canvas.width - submitButton.width) / 2;
            submitButton.draw();

            // Other buttons
            homeButton.draw();
            retryButton.draw();
        }

        // Validate username before submission
        // Note: Uses loadProfanityWords() and containsProfanity() from api-helpers.js
        function validateUsername(username) {
            username = username.trim();

            if (username.length < 3) {
                return { valid: false, error: 'Username must be at least 3 characters' };
            }

            if (username.length > 20) {
                return { valid: false, error: 'Username must be 20 characters or less' };
            }

            if (!/^[a-zA-Z0-9\s\-_]+$/.test(username)) {
                return { valid: false, error: 'Username can only contain letters, numbers, spaces, hyphens, and underscores' };
            }

            // Check for profanity (synchronous check)
            if (containsProfanity(username)) {
                return { valid: false, error: 'Username contains inappropriate content. Please choose a different username.' };
            }

            return { valid: true, username };
        }

        // Submit score to API
        async function submitScoreToAPI() {
            const validation = validateUsername(usernameInput);

            if (!validation.valid) {
                // Show error message (we'll display it on the game over screen)
                alert(validation.error);
                return;
            }

            // Disable submit button while submitting
            submitButton.color = GRAY;
            drawGameOverScreen();

            try {
                const result = await submitScore(validation.username, score);

                // Update local lists with fresh data from server
                if (result.topScores && result.topScores.length > 0) {
                    userList = result.topScores.map(s => s.username);
                    scoreList = result.topScores.map(s => s.score);
                }

                scoreSubmitted = true;
                submitButton.color = DARKGREEN;
                drawGameOverScreen();
            } catch (error) {
                console.error('Failed to submit score:', error);
                // Show error message
                alert('Failed to submit score: ' + error.message + '\n\nYour score was: ' + score);
                // Re-enable submit button
                submitButton.color = GREEN;
                scoreSubmitted = false;
                drawGameOverScreen();
            }
        }

        // Start the game when page loads

        init();
    </script>
</body>

</html>