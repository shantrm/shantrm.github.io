<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <link rel="icon" type="image/png" href="icon.png">
    <link rel="stylesheet" href="style.css">
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: black;
        }

        #gameContainer {
            text-align: center;
        }

        canvas {
            border: 2px solid white;
            display: block;
            margin: 20px auto;
            cursor: pointer;
        }

        .back-link {
            display: block;
            margin-top: 20px;
            color: white;
            text-decoration: none;
            font-family: 'Courier New', monospace;
        }

        .back-link:hover {
            text-decoration: underline;
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="608" height="480"></canvas>
        <a href="index.html" class="back-link">‚Üê Back to Home</a>
    </div>

    <!-- Load configuration and API helpers -->
    <script src="config.js"></script>
    <script src="api-helpers.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Colors matching Python version
        const BLACK = '#000000';
        const RED = '#FF0000';
        const DARK_RED = '#CC0000'; // Darker red for speed skin
        const ORANGE = '#FFA500';
        const YELLOW = '#E1FF00';
        const GREEN = '#00FF00';
        const DARKGREEN = '#008000';
        const BLUE = '#0000FF';
        const GRAY = '#C8C8C8';
        const WHITE = '#FFFFFF';
        const PURPLE = '#FF00FF';
        const DARK_PURPLE = '#7d12ff'; // Dark purple color
        const RAINBOW = 'RAINBOW'; // Special value for rainbow mode
        const HACKER_GREEN = '#00FF00'; // Hacker green color
        const HACKER = 'HACKER'; // Special value for hacker mode
        const SPEED = 'SPEED'; // Special value for speed skin (unlocks with 4x speed)
        const NINJA = 'NINJA'; // Special value for ninja skin

        // Rainbow colors array (ROYGBP: Red, Orange, Yellow, Green, Blue, Purple)
        const RAINBOW_COLORS = [RED, ORANGE, YELLOW, GREEN, BLUE, PURPLE];

        // Canvas dimensions
        const CANVAS_WIDTH = 608;
        const CANVAS_HEIGHT = 480;

        // Game object sizes
        const SEGMENT_SIZE = 20; // Size of snake segments and food
        const SEGMENT_CENTER_OFFSET = 10; // Half of SEGMENT_SIZE

        // Movement speed increments
        const MOVEMENT_STEP = 10;

        // Score thresholds
        const RAINBOW_UNLOCK_SCORE = 150;

        // Proximity threshold for food sound (in pixels)
        const FOOD_PROXIMITY_THRESHOLD = 15;

        // Score animation settings
        const SCORE_ANIMATION_DURATION = 1000; // milliseconds
        const SCORE_ANIMATION_DISTANCE = 50; // pixels to move up

        // Skin unlock requirements
        const NINJA_UNLOCK_SCORE = 100; // Score needed for ninja skin
        const NINJA_UNLOCK_SPEED = 90; // 3x speed required for ninja

        // Game settings
        let snakeColor = YELLOW;
        let speed = 30;
        let currentScreen = 'start';
        let score = 0;
        let snakeList = [];
        let snakeLength = 1;
        let snakeX = CANVAS_WIDTH / 2 - SEGMENT_CENTER_OFFSET; // Centered on canvas
        let snakeY = CANVAS_HEIGHT / 2 - SEGMENT_CENTER_OFFSET; // Centered on canvas
        let snakeXChange = 0;
        let snakeYChange = 0;
        let direction = 100;
        let foodX = 0;
        let foodY = 0;
        let gameAnimationFrame = null;
        let lastGameUpdateTime = 0;

        // Cached values to avoid recalculation every frame
        let cachedMultiplier = 1;
        let cachedFoodColor = RED;
        let usernameInput = '';
        let scoreSubmitted = false;
        let isMuted = false; // Sound mute state
        let unlockMessage = null; // Message to display when locked skin is clicked
        let unlockMessageTimeout = null; // Timeout to clear the message
        let devToolsOpen = false; // Track if DevTools is open
        let newSkinUnlocked = false; // Track if a new skin was just unlocked
        let speed3xClicks = 0; // Track clicks on + button when speed is 3x
        let is4xUnlocked = false; // Track if 4x speed is unlocked
        let shake4xOffsetX = 0; // Shake animation offset for 4x text
        let shake4xOffsetY = 0; // Shake animation offset for 4x text
        let shake4xInterval = null; // Interval for 4x shake animation
        let speedSkinShakeOffsets = []; // Array of shake offsets for each snake segment (visual only, doesn't affect hitbox)
        let speedSkinShakeInterval = null; // Interval for speed skin shake animation
        let speedButtonShakeOffsetX = 0; // Shake animation offset for speed button
        let speedButtonShakeOffsetY = 0; // Shake animation offset for speed button
        let speedButtonShakeInterval = null; // Interval for speed button shake animation

        // Check if 4x speed is unlocked
        function is4xSpeedUnlocked() {
            const unlocked = localStorage.getItem('snake4xSpeedUnlocked');
            return unlocked === 'true';
        }

        // Unlock 4x speed
        function unlock4xSpeed() {
            localStorage.setItem('snake4xSpeedUnlocked', 'true');
            is4xUnlocked = true;
        }

        // Initialize 4x unlock status
        is4xUnlocked = is4xSpeedUnlocked();

        // Highscore data (loaded from API)
        let userList = [];
        let scoreList = [];
        let speedList = [];
        let skinList = [];
        let scoreScrollIndex = 0; // Current scroll position for highscores
        const SCORES_PER_PAGE = 5; // Number of scores to show at once
        const CHUNK_SIZE = 50; // Number of scores to load at a time
        let loadedChunks = 0; // Number of chunks loaded (0 = none, 1 = first 50, 2 = first 100, etc.)
        let isLoadingScores = false;
        let scoresLoadError = null;
        let submittedScoreInfo = null; // Store submitted score info {score, username} for leaderboard jump
        let showSubmittedMessage = false; // Show "Submitted! Click for Leaderboard" message
        let blinkingScoreIndex = null; // Index of score that should blink (for highlighting)
        let blinkAnimationInterval = null; // Interval for blink animation
        let blinkBrightness = 1.0; // Brightness factor for blinking (1.0 = normal, 0.5 = dim)
        let blinkGoingDown = true; // Direction of blink animation (true = dimming, false = brightening)


        // Score animation tracking
        let scoreAnimations = []; // Array of {x, y, value, startTime, multiplier}

        // Check if rainbow skin is unlocked
        function isRainbowUnlocked() {
            const unlocked = localStorage.getItem('snakeRainbowUnlocked');
            return unlocked === 'true';
        }

        function isHackerUnlocked() {
            // Hacker skin is unlocked when DevTools is detected (easter egg)
            // Check both current state and saved state
            const saved = localStorage.getItem('snakeHackerUnlocked');
            return saved === 'true' || devToolsOpen;
        }

        // Check if speed skin is unlocked (unlocks with 4x speed)
        function isSpeedUnlocked() {
            return is4xUnlocked;
        }

        function unlockHacker() {
            localStorage.setItem('snakeHackerUnlocked', 'true');
        }

        // Unlock rainbow skin
        function unlockRainbow() {
            localStorage.setItem('snakeRainbowUnlocked', 'true');
        }

        // Check if ninja skin is unlocked
        function isNinjaUnlocked() {
            const unlocked = localStorage.getItem('snakeNinjaUnlocked');
            return unlocked === 'true';
        }

        // Unlock ninja skin
        function unlockNinja() {
            localStorage.setItem('snakeNinjaUnlocked', 'true');
        }

        // Load highscores from API (chunked loading)
        async function loadHighscores(chunkNumber = 1) {
            isLoadingScores = true;
            scoresLoadError = null;

            try {
                const limit = chunkNumber * CHUNK_SIZE;
                const scores = await getTopScores(limit);

                // Convert API response to local format
                userList = scores.map(s => s.username);
                scoreList = scores.map(s => s.score);
                speedList = scores.map(s => s.speed || null);
                skinList = scores.map(s => s.skin || null);

                loadedChunks = chunkNumber;

                // If no scores, initialize with empty arrays (no default score)
                if (userList.length === 0) {
                    userList = [];
                    scoreList = [];
                    speedList = [];
                    skinList = [];
                }
            } catch (error) {
                console.error('Failed to load highscores:', error);
                scoresLoadError = error.message;
                // Keep empty arrays on error
                userList = [];
                scoreList = [];
                speedList = [];
                skinList = [];
            } finally {
                isLoadingScores = false;
            }
        }

        // Load additional chunks if needed
        async function loadMoreChunksIfNeeded(neededChunks) {
            if (neededChunks > loadedChunks && !isLoadingScores) {
                await loadHighscores(neededChunks);
            }
        }

        // Find the chunk containing a specific score (optimized with larger initial loads)
        async function findScoreChunk(targetScore, targetUsername) {
            // Strategy: Load larger chunks first to find the score faster
            // Start with 200 scores, then 500, then 1000, etc.
            const searchChunkSizes = [200, 500, 1000, 2000, 5000];

            for (let searchSize of searchChunkSizes) {
                const chunkNum = Math.ceil(searchSize / CHUNK_SIZE);
                await loadHighscores(chunkNum);
                const combined = userList.map((user, i) => ({ user, score: scoreList[i], speed: speedList[i], skin: skinList[i] }));

                // Find the score in the current loaded scores
                const scoreIndex = combined.findIndex(s => s.score === targetScore && s.user === targetUsername);
                if (scoreIndex !== -1) {
                    // Found the score, return the chunk and index
                    return { chunkNum, index: scoreIndex };
                }

                // If we loaded fewer scores than requested, we've reached the end
                if (userList.length < searchSize) {
                    // Score not found in database, return first chunk
                    return { chunkNum: 1, index: 0 };
                }
            }

            // If still not found after loading 5000 scores, it's probably not in top 5000
            // Return first chunk
            return { chunkNum: 1, index: 0 };
        }

        // Start blink animation for highlighted score
        function startBlinkAnimation() {
            // Stop existing animation if any
            if (blinkAnimationInterval) {
                clearInterval(blinkAnimationInterval);
            }

            // Start with bright state
            blinkBrightness = 1.0;
            blinkGoingDown = true;

            // Start animation interval - toggle between two states
            blinkAnimationInterval = setInterval(function () {
                // Toggle between bright (1.0) and dim (0.4) states
                if (blinkBrightness === 1.0) {
                    blinkBrightness = 0.4; // Switch to dim
                } else {
                    blinkBrightness = 1.0; // Switch to bright
                }

                // Redraw score screen if still on score screen
                if (currentScreen === 'score') {
                    showScoreScreen(false, null); // Don't reload from API, just redraw
                }
            }, 400); // Toggle every 400ms for clear on/off blinking

            // Stop animation after 5 seconds
            setTimeout(function () {
                stopBlinkAnimation();
            }, 5000);
        }

        // Stop blink animation
        function stopBlinkAnimation() {
            if (blinkAnimationInterval) {
                clearInterval(blinkAnimationInterval);
                blinkAnimationInterval = null;
            }
            blinkBrightness = 1.0;
            blinkGoingDown = true;
            blinkingScoreIndex = null;
            // Redraw score screen if still on score screen
            if (currentScreen === 'score') {
                showScoreScreen(false, null); // Don't reload from API, just redraw
            }
        }

        // Helper function to apply brightness to a hex color
        function applyBrightness(color, brightness) {
            if (brightness >= 1.0) return color;

            // Convert hex to RGB
            const hex = color.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);

            // Apply brightness (multiply by brightness factor)
            const newR = Math.round(r * brightness);
            const newG = Math.round(g * brightness);
            const newB = Math.round(b * brightness);

            // Convert back to hex
            return '#' +
                newR.toString(16).padStart(2, '0') +
                newG.toString(16).padStart(2, '0') +
                newB.toString(16).padStart(2, '0');
        }

        // Button class (matching Python button class)
        class Button {
            constructor(color, x, y, width, height, text = '') {
                this.color = color;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.text = text;
                this.hoverColor = color;
            }

            draw() {
                // Draw button
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeStyle = BLACK;
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);

                // Draw text
                if (this.text) {
                    // Use larger font for title
                    if (this.text === 'Snake Game!') {
                        ctx.fillStyle = WHITE;
                        ctx.font = 'bold 72px Arial';
                    } else {
                        ctx.fillStyle = BLACK;
                        ctx.font = 'bold 45px Arial';
                    }
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.text, this.x + this.width / 2, this.y + this.height / 2);
                }
            }

            isOver(mouseX, mouseY) {
                return mouseX > this.x && mouseX < this.x + this.width &&
                    mouseY > this.y && mouseY < this.y + this.height;
            }
        }

        // Buttons for different screens
        let titleButton = new Button(RED, 70, 70, 475, 80, 'Snake Game!');
        let startButton = new Button(GREEN, 320, 225, 250, 100, 'Start');
        let scoreButton = new Button(YELLOW, 40, 225, 250, 100, 'Highscore');
        let settingButton = new Button(BLACK, 30, 385, 60, 60, '');
        let volumeButton = new Button(GRAY, 100, 385, 60, 60, '');
        let backButton = new Button(GRAY, 483, 430, 125, 50, 'Back');
        let homeButton = new Button(GRAY, 483, 430, 125, 50, 'Home');
        let retryButton = new Button(GRAY, 0, 430, 125, 50, 'Retry');
        let submitButton = new Button(GREEN, 230, 322, 160, 50, 'Submit');

        // Color buttons for settings (centered - 7 buttons, 50px each, 18px spacing)
        let redBtn = new Button(RED, 75, 120, 50, 50, '');
        let orangeBtn = new Button(ORANGE, 143, 120, 50, 50, '');
        let yellowBtn = new Button(YELLOW, 211, 120, 50, 50, '');
        let greenBtn = new Button(GREEN, 279, 120, 50, 50, '');
        let blueBtn = new Button(BLUE, 347, 120, 50, 50, '');
        let purpleBtn = new Button(PURPLE, 415, 120, 50, 50, '');
        let darkPurpleBtn = new Button(DARK_PURPLE, 483, 120, 50, 50, '');

        // Second row of skins (18px spacing from first row, same as button spacing)
        // Easter egg skins: Rainbow, Hacker, Speed, Ninja (in that order, last in list)
        let rainbowBtn = new Button(GRAY, 75, 188, 50, 50, '');
        let hackerBtn = new Button(BLACK, 143, 188, 50, 50, '');
        let speedBtn = new Button(RED, 211, 188, 50, 50, '');
        let ninjaBtn = new Button(WHITE, 279, 188, 50, 50, '');

        // Speed buttons
        let moreBtn = new Button(WHITE, 385, 340, 50, 50, '+');
        let lessBtn = new Button(WHITE, 168, 340, 50, 50, '-');

        // Arrow buttons for highscore scrolling
        let upArrowBtn = new Button(GRAY, 535, 145, 50, 50, '‚ñ≤');
        let downArrowBtn = new Button(GRAY, 535, 335, 50, 50, '‚ñº');

        // Preload lock image
        const lockImage = new Image();
        lockImage.src = 'lock.png';

        // Preload volume images
        const volumeImage = new Image();
        volumeImage.onload = function () {
            // Redraw start screen when image loads
            if (currentScreen === 'start') {
                drawStartScreen();
            }
        };
        volumeImage.src = 'medium-volume.png';
        const muteImage = new Image();
        muteImage.onload = function () {
            // Redraw start screen when image loads
            if (currentScreen === 'start') {
                drawStartScreen();
            }
        };
        muteImage.src = 'mute.png';

        // Preload sound and prepare for immediate playback
        const bloopSound = new Audio('bloop.mp3');
        bloopSound.preload = 'auto';
        bloopSound.load(); // Force load immediately

        // Create multiple instances for rapid playback without delay
        const bloopSound2 = new Audio('bloop.mp3');
        bloopSound2.preload = 'auto';
        bloopSound2.load();

        let currentBloopSound = bloopSound;

        // Detect console usage to unlock hacker skin
        let consoleUnlocked = false; // Track if hacker skin was unlocked via console
        function detectConsoleUsage() {
            // Override console methods to detect when user types in console
            const originalLog = console.log;
            const originalError = console.error;
            const originalWarn = console.warn;
            const originalInfo = console.info;
            const originalDebug = console.debug;

            // Function to unlock hacker skin if not already unlocked
            const unlockIfNeeded = function () {
                if (!consoleUnlocked) {
                    consoleUnlocked = true;
                    onDevToolsOpen();
                }
            };

            // Override console methods
            console.log = function (...args) {
                unlockIfNeeded();
                return originalLog.apply(console, args);
            };

            console.error = function (...args) {
                unlockIfNeeded();
                return originalError.apply(console, args);
            };

            console.warn = function (...args) {
                unlockIfNeeded();
                return originalWarn.apply(console, args);
            };

            console.info = function (...args) {
                unlockIfNeeded();
                return originalInfo.apply(console, args);
            };

            console.debug = function (...args) {
                unlockIfNeeded();
                return originalDebug.apply(console, args);
            };

            // Detect errors thrown in console (like typing undefined variables)
            // This catches ReferenceError, TypeError, etc. that occur when user types in console
            const originalOnError = window.onerror;
            window.onerror = function (message, source, lineno, colno, error) {
                // Check if error is likely from console input (not from page code)
                // Console errors typically have source as "<anonymous>" or are ReferenceErrors
                if (error && (error.name === 'ReferenceError' || error.name === 'TypeError' || error.name === 'SyntaxError')) {
                    // Check if it's from console (source is "<anonymous>" or empty)
                    if (!source || source.includes('<anonymous>') || source === '') {
                        unlockIfNeeded();
                    }
                }
                // Call original error handler if it exists
                if (originalOnError) {
                    return originalOnError.apply(window, arguments);
                }
                return false;
            };

            // Also use addEventListener for error events (more modern approach)
            window.addEventListener('error', function (event) {
                // Check if error is from console input
                if (event.error && (event.error.name === 'ReferenceError' || event.error.name === 'TypeError' || event.error.name === 'SyntaxError')) {
                    // Check if source is from console
                    if (!event.filename || event.filename.includes('<anonymous>') || event.filename === '') {
                        unlockIfNeeded();
                    }
                }
            }, true); // Use capture phase to catch all errors
        }

        // Callback when DevTools is opened
        function onDevToolsOpen() {
            console.log('Devtools Opened');
            // Check if hacker skin is already saved in localStorage (before unlocking)
            const wasSaved = localStorage.getItem('snakeHackerUnlocked') === 'true';
            // Unlock hacker skin permanently (save to localStorage)
            unlockHacker();
            // If it was just unlocked (not already saved), show notification
            if (!wasSaved) {
                newSkinUnlocked = true; // Show notification immediately
                // Redraw current screen to show notification (except game screen)
                if (currentScreen === 'start') {
                    drawStartScreen();
                } else if (currentScreen === 'settings') {
                    showSettingsScreen();
                } else if (currentScreen === 'score') {
                    showScoreScreen(false);
                } else if (currentScreen === 'gameover') {
                    drawGameOverScreen();
                }
            }
        }

        // Callback when DevTools is closed
        function onDevToolsClose() {
            // Add your custom logic here
        }

        // Initialize game
        async function init() {
            // Check if hacker skin was previously unlocked
            const hackerUnlocked = localStorage.getItem('snakeHackerUnlocked');
            if (hackerUnlocked === 'true') {
                // Hacker skin is already unlocked, ensure it's available
                devToolsOpen = true; // Set flag so isHackerUnlocked() returns true
                consoleUnlocked = true; // Mark as already unlocked
            }
            detectConsoleUsage(); // Start console usage detection
            drawStartScreen();

            // Preload profanity wordlist (async, don't block UI)
            loadProfanityWords().catch(err => {
                console.error('Failed to preload profanity wordlist:', err);
            });

            // Load highscores from API (async, but don't block UI)
            loadHighscores().catch(err => {
                console.error('Failed to load initial highscores:', err);
            });

            // Mouse event listeners
            canvas.addEventListener('click', handleClick);
            canvas.addEventListener('mousemove', handleMouseMove);

            // Keyboard event listeners
            document.addEventListener('keydown', handleKeyDown);
        }

        // Handle mouse clicks
        function handleClick(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (currentScreen === 'start') {
                if (startButton.isOver(mouseX, mouseY)) {
                    startGame();
                } else if (scoreButton.isOver(mouseX, mouseY)) {
                    showScoreScreen();
                } else if (settingButton.isOver(mouseX, mouseY)) {
                    newSkinUnlocked = false; // Clear notification when settings is clicked
                    showSettingsScreen();
                } else if (volumeButton.isOver(mouseX, mouseY)) {
                    isMuted = !isMuted;
                    drawStartScreen();
                }
            } else if (currentScreen === 'score') {
                if (backButton.isOver(mouseX, mouseY)) {
                    stopBlinkAnimation(); // Stop blink animation when leaving score screen
                    drawStartScreen();
                } else if (upArrowBtn.isOver(mouseX, mouseY)) {
                    if (scoreScrollIndex > 0) {
                        scoreScrollIndex -= SCORES_PER_PAGE;
                        if (scoreScrollIndex < 0) scoreScrollIndex = 0;
                        showScoreScreen(false); // Don't reload from API on scroll
                    }
                } else if (downArrowBtn.isOver(mouseX, mouseY)) {
                    const combined = userList.map((user, i) => ({ user, score: scoreList[i], speed: speedList[i], skin: skinList[i] }));
                    combined.sort((a, b) => b.score - a.score);
                    const newScrollIndex = scoreScrollIndex + SCORES_PER_PAGE;

                    // Check if we need to load more chunks
                    const neededChunks = Math.ceil((newScrollIndex + SCORES_PER_PAGE) / CHUNK_SIZE);
                    if (neededChunks > loadedChunks) {
                        // Load more chunks first
                        loadMoreChunksIfNeeded(neededChunks).then(() => {
                            // After loading, recalculate and scroll
                            const updatedCombined = userList.map((user, i) => ({ user, score: scoreList[i], speed: speedList[i], skin: skinList[i] }));
                            updatedCombined.sort((a, b) => b.score - a.score);
                            const maxScroll = Math.max(0, updatedCombined.length - SCORES_PER_PAGE);
                            scoreScrollIndex = Math.min(newScrollIndex, maxScroll);
                            showScoreScreen(false); // Don't reload from API on scroll
                        });
                    } else {
                        const maxScroll = Math.max(0, combined.length - SCORES_PER_PAGE);
                        if (scoreScrollIndex < maxScroll) {
                            scoreScrollIndex += SCORES_PER_PAGE;
                            if (scoreScrollIndex > maxScroll) scoreScrollIndex = maxScroll;
                            showScoreScreen(false); // Don't reload from API on scroll
                        }
                    }
                }
            } else if (currentScreen === 'settings') {
                if (backButton.isOver(mouseX, mouseY)) {
                    unlockMessage = null; // Clear message when leaving settings
                    if (unlockMessageTimeout) {
                        clearTimeout(unlockMessageTimeout);
                        unlockMessageTimeout = null;
                    }
                    drawStartScreen();
                } else if (redBtn.isOver(mouseX, mouseY)) {
                    snakeColor = RED;
                    updateCachedValues(); // Update cached food color
                    unlockMessage = null; // Clear message when selecting unlocked skin
                    if (unlockMessageTimeout) {
                        clearTimeout(unlockMessageTimeout);
                        unlockMessageTimeout = null;
                    }
                    showSettingsScreen();
                } else if (orangeBtn.isOver(mouseX, mouseY)) {
                    snakeColor = ORANGE;
                    updateCachedValues();
                    unlockMessage = null;
                    if (unlockMessageTimeout) {
                        clearTimeout(unlockMessageTimeout);
                        unlockMessageTimeout = null;
                    }
                    showSettingsScreen();
                } else if (yellowBtn.isOver(mouseX, mouseY)) {
                    snakeColor = YELLOW;
                    updateCachedValues();
                    unlockMessage = null;
                    if (unlockMessageTimeout) {
                        clearTimeout(unlockMessageTimeout);
                        unlockMessageTimeout = null;
                    }
                    showSettingsScreen();
                } else if (greenBtn.isOver(mouseX, mouseY)) {
                    snakeColor = GREEN;
                    updateCachedValues();
                    unlockMessage = null;
                    if (unlockMessageTimeout) {
                        clearTimeout(unlockMessageTimeout);
                        unlockMessageTimeout = null;
                    }
                    showSettingsScreen();
                } else if (blueBtn.isOver(mouseX, mouseY)) {
                    snakeColor = BLUE;
                    updateCachedValues();
                    unlockMessage = null;
                    if (unlockMessageTimeout) {
                        clearTimeout(unlockMessageTimeout);
                        unlockMessageTimeout = null;
                    }
                    showSettingsScreen();
                } else if (purpleBtn.isOver(mouseX, mouseY)) {
                    snakeColor = PURPLE;
                    updateCachedValues();
                    unlockMessage = null;
                    if (unlockMessageTimeout) {
                        clearTimeout(unlockMessageTimeout);
                        unlockMessageTimeout = null;
                    }
                    showSettingsScreen();
                } else if (darkPurpleBtn.isOver(mouseX, mouseY)) {
                    snakeColor = DARK_PURPLE;
                    updateCachedValues();
                    unlockMessage = null;
                    if (unlockMessageTimeout) {
                        clearTimeout(unlockMessageTimeout);
                        unlockMessageTimeout = null;
                    }
                    showSettingsScreen();
                } else if (rainbowBtn.isOver(mouseX, mouseY)) {
                    if (isRainbowUnlocked()) {
                        snakeColor = RAINBOW;
                        updateCachedValues();
                        unlockMessage = null; // Clear message when unlocked skin is selected
                        if (unlockMessageTimeout) {
                            clearTimeout(unlockMessageTimeout);
                            unlockMessageTimeout = null;
                        }
                        showSettingsScreen();
                    } else {
                        // Show unlock message for locked rainbow skin
                        if (unlockMessageTimeout) {
                            clearTimeout(unlockMessageTimeout);
                        }
                        unlockMessage = 'Score > ' + RAINBOW_UNLOCK_SCORE + ' to unlock!';
                        unlockMessageTimeout = setTimeout(() => {
                            unlockMessage = null;
                            unlockMessageTimeout = null;
                            showSettingsScreen();
                        }, 3000); // Clear after 3 seconds
                        showSettingsScreen();
                    }
                } else if (speedBtn.isOver(mouseX, mouseY)) {
                    if (isSpeedUnlocked()) {
                        snakeColor = SPEED;
                        updateCachedValues();
                        unlockMessage = null; // Clear message when unlocked skin is selected
                        if (unlockMessageTimeout) {
                            clearTimeout(unlockMessageTimeout);
                            unlockMessageTimeout = null;
                        }
                        showSettingsScreen();
                    } else {
                        // Show unlock message for locked speed skin
                        if (unlockMessageTimeout) {
                            clearTimeout(unlockMessageTimeout);
                        }
                        unlockMessage = 'Easter Egg!';
                        unlockMessageTimeout = setTimeout(() => {
                            unlockMessage = null;
                            unlockMessageTimeout = null;
                            showSettingsScreen();
                        }, 3000); // Clear after 3 seconds
                        showSettingsScreen();
                    }
                } else if (hackerBtn.isOver(mouseX, mouseY)) {
                    if (isHackerUnlocked()) {
                        snakeColor = HACKER;
                        updateCachedValues();
                        unlockMessage = null; // Clear message when unlocked skin is selected
                        if (unlockMessageTimeout) {
                            clearTimeout(unlockMessageTimeout);
                            unlockMessageTimeout = null;
                        }
                        showSettingsScreen();
                    } else {
                        // Show unlock message for locked hacker skin
                        if (unlockMessageTimeout) {
                            clearTimeout(unlockMessageTimeout);
                        }
                        unlockMessage = 'Easter Egg!';
                        unlockMessageTimeout = setTimeout(() => {
                            unlockMessage = null;
                            unlockMessageTimeout = null;
                            showSettingsScreen();
                        }, 3000); // Clear after 3 seconds
                        showSettingsScreen();
                    }
                } else if (ninjaBtn.isOver(mouseX, mouseY)) {
                    if (isNinjaUnlocked()) {
                        snakeColor = NINJA;
                        updateCachedValues();
                        unlockMessage = null; // Clear message when unlocked skin is selected
                        if (unlockMessageTimeout) {
                            clearTimeout(unlockMessageTimeout);
                            unlockMessageTimeout = null;
                        }
                        showSettingsScreen();
                    } else {
                        // Show unlock message for locked ninja skin
                        if (unlockMessageTimeout) {
                            clearTimeout(unlockMessageTimeout);
                        }
                        unlockMessage = 'Score > ' + NINJA_UNLOCK_SCORE + ' on 3x speed!';
                        unlockMessageTimeout = setTimeout(() => {
                            unlockMessage = null;
                            unlockMessageTimeout = null;
                            showSettingsScreen();
                        }, 3000); // Clear after 3 seconds
                        showSettingsScreen();
                    }
                } else if (moreBtn.isOver(mouseX, mouseY)) {
                    if (speed === 90) {
                        if (is4xUnlocked) {
                            // If 4x is already unlocked, go directly to 4x
                            speed = 120;
                            speed3xClicks = 0; // Reset counter
                        } else {
                            // Count clicks on + button when at 3x speed
                            speed3xClicks++;
                            if (speed3xClicks >= 10) {
                                // Unlock 4x speed
                                unlock4xSpeed();
                                speed = 120; // Set to 4x speed
                                speed3xClicks = 0; // Reset counter
                            }
                        }
                    } else if (speed === 120) {
                        // At 4x, don't loop back - stay at 4x (max speed)
                        speed3xClicks = 0; // Reset counter
                    } else if (speed === 15) {
                        speed = 30;
                        speed3xClicks = 0; // Reset counter
                    } else {
                        speed += 30;
                        speed3xClicks = 0; // Reset counter when speed changes
                    }
                    updateCachedValues(); // Update cached multiplier
                    showSettingsScreen();
                } else if (lessBtn.isOver(mouseX, mouseY)) {
                    if (speed === 120) {
                        // From 4x, go back to 3x
                        speed = 90;
                        speed3xClicks = 0; // Reset counter
                    } else if (speed === 30) {
                        speed = 15;
                        speed3xClicks = 0; // Reset counter
                    } else if (speed === 15) {
                        // Min speed
                    } else {
                        speed -= 30;
                        speed3xClicks = 0; // Reset counter when speed changes
                    }
                    updateCachedValues(); // Update cached multiplier
                    showSettingsScreen();
                }
            } else if (currentScreen === 'gameover') {
                if (homeButton.isOver(mouseX, mouseY)) {
                    showSubmittedMessage = false; // Clear message when leaving
                    submittedScoreInfo = null;
                    drawStartScreen();
                } else if (retryButton.isOver(mouseX, mouseY)) {
                    showSubmittedMessage = false; // Clear message when starting new game
                    submittedScoreInfo = null;
                    startGame();
                } else if (submitButton.isOver(mouseX, mouseY) && !scoreSubmitted && usernameInput.trim() !== '') {
                    scoreSubmitted = true; // Prevent multiple clicks immediately
                    submitScoreToAPI();
                } else if (showSubmittedMessage && scoreSubmitted) {
                    // Check if click is on the "Submitted! Click for Leaderboard" message
                    // Message is centered at x=304, y=395, approximate width ~300px, height ~25px
                    const messageX = 304;
                    const messageY = 395;
                    const messageWidth = 300;
                    const messageHeight = 25;
                    if (mouseX >= messageX - messageWidth / 2 && mouseX <= messageX + messageWidth / 2 &&
                        mouseY >= messageY - messageHeight / 2 && mouseY <= messageY + messageHeight / 2) {
                        // Clicked on message - jump to leaderboard and find the submitted score
                        if (submittedScoreInfo) {
                            (async () => {
                                const result = await findScoreChunk(submittedScoreInfo.score, submittedScoreInfo.username);
                                // Set blinking score index to highlight the submitted score
                                blinkingScoreIndex = result.index;
                                startBlinkAnimation();
                                showScoreScreen(true, result.index); // Reload from API and jump to index
                            })();
                        } else {
                            showScoreScreen(true);
                        }
                    }
                }
            }
        }

        // Handle mouse movement for hover effects
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (currentScreen === 'start') {
                let newStartColor = startButton.isOver(mouseX, mouseY) ? RED : GREEN;
                let newScoreColor = scoreButton.isOver(mouseX, mouseY) ? BLUE : YELLOW;

                // Only redraw if colors changed
                if (startButton.color !== newStartColor || scoreButton.color !== newScoreColor) {
                    startButton.color = newStartColor;
                    scoreButton.color = newScoreColor;

                    // Clear and redraw only the buttons
                    ctx.fillStyle = BLACK;
                    ctx.fillRect(startButton.x, startButton.y, startButton.width, startButton.height);
                    ctx.fillRect(scoreButton.x, scoreButton.y, scoreButton.width, scoreButton.height);

                    startButton.draw();
                    scoreButton.draw();
                }
            } else if (currentScreen === 'score') {
                let newBackColor = backButton.isOver(mouseX, mouseY) ? WHITE : GRAY;
                let newUpArrowColor = upArrowBtn.isOver(mouseX, mouseY) ? WHITE : GRAY;
                let newDownArrowColor = downArrowBtn.isOver(mouseX, mouseY) ? WHITE : GRAY;

                const combined = userList.map((user, i) => ({ user, score: scoreList[i] }));
                combined.sort((a, b) => b.score - a.score);
                const maxScroll = Math.max(0, combined.length - SCORES_PER_PAGE);

                // Only show hover if arrow is visible
                if (scoreScrollIndex <= 0) newUpArrowColor = GRAY;
                if (scoreScrollIndex >= maxScroll) newDownArrowColor = GRAY;

                if (backButton.color !== newBackColor || upArrowBtn.color !== newUpArrowColor || downArrowBtn.color !== newDownArrowColor) {
                    backButton.color = newBackColor;
                    upArrowBtn.color = newUpArrowColor;
                    downArrowBtn.color = newDownArrowColor;

                    ctx.fillStyle = BLACK;
                    ctx.fillRect(backButton.x, backButton.y, backButton.width, backButton.height);
                    if (scoreScrollIndex > 0) {
                        ctx.fillRect(upArrowBtn.x, upArrowBtn.y, upArrowBtn.width, upArrowBtn.height);
                    }
                    if (scoreScrollIndex < maxScroll) {
                        ctx.fillRect(downArrowBtn.x, downArrowBtn.y, downArrowBtn.width, downArrowBtn.height);
                    }

                    backButton.draw();
                    if (scoreScrollIndex > 0) upArrowBtn.draw();
                    if (scoreScrollIndex < maxScroll) downArrowBtn.draw();
                }
            } else if (currentScreen === 'settings') {
                let newBackColor = backButton.isOver(mouseX, mouseY) ? WHITE : GRAY;
                let newMoreColor = moreBtn.isOver(mouseX, mouseY) ? GRAY : WHITE;
                let newLessColor = lessBtn.isOver(mouseX, mouseY) ? GRAY : WHITE;

                if (backButton.color !== newBackColor || moreBtn.color !== newMoreColor || lessBtn.color !== newLessColor) {
                    backButton.color = newBackColor;
                    moreBtn.color = newMoreColor;
                    lessBtn.color = newLessColor;

                    // Clear button areas
                    ctx.fillStyle = BLACK;
                    ctx.fillRect(moreBtn.x, moreBtn.y, moreBtn.width, moreBtn.height);
                    ctx.fillRect(lessBtn.x, lessBtn.y, lessBtn.width, lessBtn.height);
                    ctx.fillRect(backButton.x, backButton.y, backButton.width, backButton.height);

                    moreBtn.draw();
                    lessBtn.draw();
                    backButton.draw();
                }
            } else if (currentScreen === 'gameover') {
                let newHomeColor = homeButton.isOver(mouseX, mouseY) ? WHITE : GRAY;
                let newRetryColor = retryButton.isOver(mouseX, mouseY) ? WHITE : GRAY;

                // Check if hovering over the "Submitted! Click for Leaderboard" message
                let isHoveringMessage = false;
                if (showSubmittedMessage && scoreSubmitted) {
                    const messageX = 304;
                    const messageY = 395;
                    const messageWidth = 300;
                    const messageHeight = 25;
                    isHoveringMessage = (mouseX >= messageX - messageWidth / 2 && mouseX <= messageX + messageWidth / 2 &&
                        mouseY >= messageY - messageHeight / 2 && mouseY <= messageY + messageHeight / 2);
                }

                // Change cursor style
                canvas.style.cursor = isHoveringMessage ? 'pointer' : 'default';

                if (homeButton.color !== newHomeColor || retryButton.color !== newRetryColor) {
                    homeButton.color = newHomeColor;
                    retryButton.color = newRetryColor;

                    // Clear button areas
                    ctx.fillStyle = BLACK;
                    ctx.fillRect(homeButton.x, homeButton.y, homeButton.width, homeButton.height);
                    ctx.fillRect(retryButton.x, retryButton.y, retryButton.width, retryButton.height);

                    homeButton.draw();
                    retryButton.draw();
                }
            }
        }

        // Handle keyboard input
        function handleKeyDown(e) {
            if (currentScreen === 'game') {
                if (e.key === 'ArrowLeft' && direction !== 1) {
                    direction = 3;
                    snakeXChange = -MOVEMENT_STEP;
                    snakeYChange = 0;
                } else if (e.key === 'ArrowRight' && direction !== 3) {
                    direction = 1;
                    snakeXChange = MOVEMENT_STEP;
                    snakeYChange = 0;
                } else if (e.key === 'ArrowUp' && direction !== 4) {
                    direction = 2;
                    snakeYChange = -MOVEMENT_STEP;
                    snakeXChange = 0;
                } else if (e.key === 'ArrowDown' && direction !== 2) {
                    direction = 4;
                    snakeYChange = MOVEMENT_STEP;
                    snakeXChange = 0;
                }
            } else if (currentScreen === 'gameover') {
                if (e.key === 'Backspace') {
                    usernameInput = usernameInput.slice(0, -1);
                    drawGameOverScreen();
                } else if (e.key.length === 1 && usernameInput.length < 20) { // Increased to 20 to match DB limit
                    // Only allow alphanumeric, spaces, hyphens, underscores
                    const char = e.key;
                    if (/^[a-zA-Z0-9\s\-_]$/.test(char)) {
                        usernameInput += char;
                        drawGameOverScreen();
                    }
                }
            }
        }

        // Draw settings icon (simple gear)
        function drawSettingsIcon() {
            ctx.fillStyle = GRAY;
            ctx.font = 'bold 80px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚öô', 60, 419);
        }

        // Draw volume icon
        function drawVolumeIcon() {
            // Center the icon on the button (button is at 100, 380 with size 60x60)
            const iconSize = 50; // Larger icon
            const iconX = 100 + (60 - iconSize) / 2; // Center horizontally
            const iconY = 385 + (60 - iconSize) / 2; // Center vertically

            if (isMuted) {
                // Draw mute icon
                if (muteImage.complete && muteImage.naturalWidth > 0) {
                    ctx.drawImage(muteImage, iconX, iconY, iconSize, iconSize);
                } else {
                    // Fallback: draw a simple mute symbol if image not loaded
                    ctx.fillStyle = WHITE;
                    ctx.font = 'bold 40px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('üîá', iconX + iconSize / 2, iconY + iconSize / 2 + 15);
                }
            } else {
                // Draw volume icon (unmuted - default state)
                if (volumeImage.complete && volumeImage.naturalWidth > 0) {
                    ctx.drawImage(volumeImage, iconX, iconY, iconSize, iconSize);
                } else {
                    // Fallback: draw a simple volume symbol if image not loaded
                    ctx.fillStyle = WHITE;
                    ctx.font = 'bold 40px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('üîä', iconX + iconSize / 2, iconY + iconSize / 2 + 15);
                }
            }
        }

        // Draw start screen
        function drawStartScreen() {
            // Stop 4x shake animation when leaving settings
            if (shake4xInterval) {
                clearInterval(shake4xInterval);
                shake4xInterval = null;
                shake4xOffsetX = 0;
                shake4xOffsetY = 0;
            }
            // Stop speed button shake animation when leaving settings
            if (speedButtonShakeInterval) {
                clearInterval(speedButtonShakeInterval);
                speedButtonShakeInterval = null;
                speedButtonShakeOffsetX = 0;
                speedButtonShakeOffsetY = 0;
            }
            currentScreen = 'start';
            ctx.fillStyle = BLACK;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title button
            titleButton.draw();

            // Buttons
            startButton.draw();
            scoreButton.draw();
            settingButton.draw();
            drawSettingsIcon();
            volumeButton.draw();
            drawVolumeIcon();

            // Display new skin unlock notification in top right
            if (newSkinUnlocked) {
                ctx.fillStyle = BLACK;
                ctx.fillRect(450, 10, 150, 40);
                ctx.fillStyle = GREEN;
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'right';
                ctx.fillText('New Skin Unlock', 590, 35);
            }
        }

        // Show settings screen
        function showSettingsScreen() {
            currentScreen = 'settings';
            ctx.fillStyle = BLACK;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title for colors
            ctx.fillStyle = WHITE;
            ctx.font = 'bold 50px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Colors!', 304, 60);

            // Title for speed
            ctx.fillText('Speed!', 304, 300);

            // Speed number
            let speedNum = speed / 30;
            if (speed === 15) speedNum = 0.5;
            if (speed === 120) {
                // Display 4x in red with shake animation
                ctx.fillStyle = RED;
                ctx.fillText('4x', 304 + shake4xOffsetX, 370 + shake4xOffsetY);

                // Start shake animation if not already running
                if (!shake4xInterval) {
                    shake4xInterval = setInterval(function () {
                        // Random shake offset between -3 and 3 pixels
                        shake4xOffsetX = (Math.random() - 0.5) * 6;
                        shake4xOffsetY = (Math.random() - 0.5) * 6;
                        // Only redraw if still on settings screen
                        if (currentScreen === 'settings') {
                            // Clear the speed number area and redraw
                            ctx.fillStyle = BLACK;
                            ctx.fillRect(250, 340, 110, 50);
                            // Redraw speed number with shake
                            ctx.fillStyle = RED;
                            ctx.font = 'bold 50px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('4x', 304 + shake4xOffsetX, 370 + shake4xOffsetY);
                        }
                    }, 50); // Update every 50ms for smooth animation
                }
            } else {
                // Stop shake animation if speed is not 4x
                if (shake4xInterval) {
                    clearInterval(shake4xInterval);
                    shake4xInterval = null;
                    shake4xOffsetX = 0;
                    shake4xOffsetY = 0;
                }
                ctx.fillStyle = WHITE;
                ctx.fillText(speedNum.toString(), 304, 370);
            }

            // Draw color buttons
            redBtn.draw();
            orangeBtn.draw();
            yellowBtn.draw();
            greenBtn.draw();
            blueBtn.draw();
            purpleBtn.draw();
            darkPurpleBtn.draw();

            // Draw second row buttons - Easter egg skins (Rainbow, Hacker, Speed, Ninja)
            // Rainbow button (first in row, bright if unlocked, dim if locked)
            const gradient = ctx.createLinearGradient(75, 188, 125, 238);
            if (isRainbowUnlocked()) {
                // Bright colors for unlocked
                gradient.addColorStop(0, RED);
                gradient.addColorStop(0.2, ORANGE);
                gradient.addColorStop(0.4, YELLOW);
                gradient.addColorStop(0.6, GREEN);
                gradient.addColorStop(0.8, BLUE);
                gradient.addColorStop(1, PURPLE);
            } else {
                // Dimmer colors for locked
                gradient.addColorStop(0, '#990000'); // Dimmed RED
                gradient.addColorStop(0.2, '#996300'); // Dimmed ORANGE
                gradient.addColorStop(0.4, '#879900'); // Dimmed YELLOW
                gradient.addColorStop(0.6, '#009900'); // Dimmed GREEN
                gradient.addColorStop(0.8, '#000099'); // Dimmed BLUE
                gradient.addColorStop(1, '#990099'); // Dimmed PURPLE
            }
            ctx.fillStyle = gradient;
            ctx.fillRect(75, 188, 50, 50);
            ctx.strokeStyle = BLACK;
            ctx.lineWidth = 2;
            ctx.strokeRect(75, 188, 50, 50);

            // Draw lock image if locked
            if (!isRainbowUnlocked()) {
                // Draw lock image if loaded
                if (lockImage.complete && lockImage.naturalWidth > 0) {
                    ctx.drawImage(lockImage, 75 + 10, 188 + 10, 30, 30);
                } else {
                    // Fallback to text if image not loaded yet
                    ctx.fillStyle = WHITE;
                    ctx.font = 'bold 30px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('üîí', 100, 218);
                }
            }

            // Hacker button (second in row, black with green neon outline, or dimmed if locked)
            if (isHackerUnlocked()) {
                ctx.fillStyle = BLACK;
                ctx.fillRect(143, 188, 50, 50);
                ctx.strokeStyle = HACKER_GREEN;
                ctx.lineWidth = 3;
                ctx.strokeRect(143, 188, 50, 50);
            } else {
                ctx.fillStyle = '#1a1a1a'; // Dimmed black
                ctx.fillRect(143, 188, 50, 50);
                ctx.strokeStyle = '#006600'; // Dimmed green
                ctx.lineWidth = 2;
                ctx.strokeRect(143, 188, 50, 50);
                // Draw lock image if locked
                if (lockImage.complete && lockImage.naturalWidth > 0) {
                    ctx.drawImage(lockImage, 143 + 10, 188 + 10, 30, 30);
                } else {
                    ctx.fillStyle = WHITE;
                    ctx.font = 'bold 30px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('üîí', 168, 218);
                }
            }

            // Draw speed button (red, or dimmed if locked)
            if (isSpeedUnlocked()) {
                // Start shake animation for unlocked speed button if not already running
                if (!speedButtonShakeInterval) {
                    speedButtonShakeInterval = setInterval(function () {
                        // Update shake offset (reduced: random offset between -2 and 2 pixels)
                        speedButtonShakeOffsetX = (Math.random() - 0.5) * 4;
                        speedButtonShakeOffsetY = (Math.random() - 0.5) * 4;
                        // Redraw settings screen if still on settings
                        if (currentScreen === 'settings') {
                            showSettingsScreen();
                        }
                    }, 75); // Update every 75ms for smoother, less aggressive animation
                }
                // Draw button with shake offset
                ctx.fillStyle = DARK_RED;
                ctx.fillRect(211 + speedButtonShakeOffsetX, 188 + speedButtonShakeOffsetY, 50, 50);
            } else {
                // Stop shake animation if button is locked
                if (speedButtonShakeInterval) {
                    clearInterval(speedButtonShakeInterval);
                    speedButtonShakeInterval = null;
                    speedButtonShakeOffsetX = 0;
                    speedButtonShakeOffsetY = 0;
                }
                ctx.fillStyle = '#800000'; // Dimmed dark red
                ctx.fillRect(211, 188, 50, 50);
                // Draw lock image if locked
                if (lockImage.complete && lockImage.naturalWidth > 0) {
                    ctx.drawImage(lockImage, 211 + 10, 188 + 10, 30, 30);
                } else {
                    ctx.fillStyle = WHITE;
                    ctx.font = 'bold 30px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('üîí', 236, 218);
                }
            }

            // Draw ninja button (white to black gradient, or dimmed if locked)
            if (isNinjaUnlocked()) {
                // Draw white to black gradient
                const ninjaGradient = ctx.createLinearGradient(279, 188, 329, 238);
                ninjaGradient.addColorStop(0, WHITE);
                ninjaGradient.addColorStop(1, '#010101'); // Almost black (one value before pure black)
                ctx.fillStyle = ninjaGradient;
                ctx.fillRect(279, 188, 50, 50);
            } else {
                ctx.fillStyle = '#808080'; // Dimmed gray
                ctx.fillRect(279, 188, 50, 50);
                // Draw lock image if locked
                if (lockImage.complete && lockImage.naturalWidth > 0) {
                    ctx.drawImage(lockImage, 279 + 10, 188 + 10, 30, 30);
                } else {
                    ctx.fillStyle = WHITE;
                    ctx.font = 'bold 30px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('üîí', 304, 218);
                }
            }
            ctx.strokeStyle = BLACK;
            ctx.lineWidth = 2;
            ctx.strokeRect(279, 188, 50, 50);

            // Highlight selected color
            let selectX, selectY;
            if (snakeColor === RED) { selectX = 70; selectY = 115; }
            else if (snakeColor === ORANGE) { selectX = 138; selectY = 115; }
            else if (snakeColor === YELLOW) { selectX = 206; selectY = 115; }
            else if (snakeColor === GREEN) { selectX = 274; selectY = 115; }
            else if (snakeColor === BLUE) { selectX = 342; selectY = 115; }
            else if (snakeColor === PURPLE) { selectX = 410; selectY = 115; }
            else if (snakeColor === DARK_PURPLE) { selectX = 478; selectY = 115; }
            else if (snakeColor === RAINBOW) { selectX = 70; selectY = 183; }
            else if (snakeColor === HACKER) { selectX = 138; selectY = 183; }
            else if (snakeColor === SPEED) { selectX = 206 + speedButtonShakeOffsetX; selectY = 183 + speedButtonShakeOffsetY; }
            else if (snakeColor === NINJA) { selectX = 274; selectY = 183; }

            ctx.strokeStyle = WHITE;
            ctx.lineWidth = 5;
            ctx.strokeRect(selectX, selectY, 60, 60);

            // Speed buttons
            moreBtn.draw();
            lessBtn.draw();

            // Back button
            backButton.draw();

            // Display unlock message in top right if set
            if (unlockMessage) {
                ctx.fillStyle = WHITE;
                ctx.font = '18px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(unlockMessage, 590, 30);
            }

            // Display new skin unlock notification in top right
            if (newSkinUnlocked) {
                ctx.fillStyle = BLACK;
                ctx.fillRect(450, 10, 150, 40);
                ctx.fillStyle = GREEN;
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'right';
                ctx.fillText('New Skin Unlock', 590, 35);
            }
        }

        // Show score screen
        async function showScoreScreen(reloadFromAPI = true, targetIndex = null) {
            // Stop 4x shake animation when leaving settings
            if (shake4xInterval) {
                clearInterval(shake4xInterval);
                shake4xInterval = null;
                shake4xOffsetX = 0;
                shake4xOffsetY = 0;
            }
            // Stop speed button shake animation when leaving settings
            if (speedButtonShakeInterval) {
                clearInterval(speedButtonShakeInterval);
                speedButtonShakeInterval = null;
                speedButtonShakeOffsetX = 0;
                speedButtonShakeOffsetY = 0;
            }
            // Don't stop blink animation here - it should continue if already running
            currentScreen = 'score';
            ctx.fillStyle = BLACK;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Reload scores from API only if requested (not on scroll)
            if (reloadFromAPI) {
                await loadHighscores(1); // Load first chunk
            }

            // Combine and sort (already sorted by API, but ensure consistency)
            let combined = userList.map((user, i) => ({ user, score: scoreList[i], speed: speedList[i], skin: skinList[i] }));
            combined.sort((a, b) => b.score - a.score);

            // If targetIndex is provided, scroll to that index
            if (targetIndex !== null) {
                // Calculate which chunk contains this index
                const neededChunks = Math.ceil((targetIndex + 1) / CHUNK_SIZE);
                await loadMoreChunksIfNeeded(neededChunks);
                // Reload combined after loading more chunks
                combined = userList.map((user, i) => ({ user, score: scoreList[i], speed: speedList[i], skin: skinList[i] }));
                combined.sort((a, b) => b.score - a.score);

                // Center the target score in the middle (3rd position) of the 5 scores displayed
                const middlePosition = Math.floor(SCORES_PER_PAGE / 2); // 2 (for 5 scores, middle is index 2)
                let desiredScrollIndex = targetIndex - middlePosition;

                // Handle edge cases
                if (desiredScrollIndex < 0) {
                    // Target is near the top, start at 0
                    desiredScrollIndex = 0;
                } else if (desiredScrollIndex + SCORES_PER_PAGE > combined.length) {
                    // Target is near the bottom, show last page
                    desiredScrollIndex = Math.max(0, combined.length - SCORES_PER_PAGE);
                }

                scoreScrollIndex = desiredScrollIndex;

                // Set blinking score index if not already set
                if (blinkingScoreIndex === null) {
                    blinkingScoreIndex = targetIndex;
                }
                // Start blink animation if not already running
                if (!blinkAnimationInterval) {
                    startBlinkAnimation();
                }
            }

            // Reset scroll if out of bounds
            const maxScroll = Math.max(0, combined.length - SCORES_PER_PAGE);
            if (scoreScrollIndex > maxScroll) {
                scoreScrollIndex = maxScroll;
            }

            // Check if we need to load more chunks based on current scroll position
            const currentEndIndex = scoreScrollIndex + SCORES_PER_PAGE;
            const neededChunks = Math.ceil(currentEndIndex / CHUNK_SIZE);
            if (neededChunks > loadedChunks && !isLoadingScores) {
                // Load more chunks in background
                loadMoreChunksIfNeeded(neededChunks).then(() => {
                    // Redraw if still on score screen
                    if (currentScreen === 'score') {
                        showScoreScreen(false, null); // Don't reload from API, just redraw
                    }
                });
            }

            // Title
            ctx.fillStyle = BLUE;
            ctx.fillRect(90, 50, 430, 80);
            ctx.fillStyle = WHITE;
            ctx.font = 'bold 72px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Highscores:', 100, 105);

            // Show loading or error message
            if (isLoadingScores) {
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Loading scores...', 304, 245);
                backButton.draw();
                return;
            }

            if (scoresLoadError) {
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = RED;
                ctx.fillText('Failed to load scores', 304, 225);
                ctx.fillStyle = WHITE;
                ctx.font = '18px Arial';
                ctx.fillText('Check your connection', 304, 255);
                backButton.draw();
                return;
            }

            // Display paginated scores
            if (combined.length === 0) {
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No scores yet!', 304, 245);
                ctx.fillText('Be the first!', 304, 285);
            } else {
                ctx.font = '30px Arial';
                ctx.textAlign = 'left';
                let y = 165;
                const startIndex = scoreScrollIndex;
                const endIndex = Math.min(startIndex + SCORES_PER_PAGE, combined.length);

                for (let i = startIndex; i < endIndex; i++) {
                    const rank = i + 1;
                    const isBlinking = (blinkingScoreIndex !== null && i === blinkingScoreIndex);

                    // Apply brightness/dimming if this score is blinking
                    if (isBlinking) {
                        ctx.globalAlpha = blinkBrightness;
                    } else {
                        ctx.globalAlpha = 1.0;
                    }

                    // Display rank
                    ctx.fillStyle = WHITE;
                    ctx.fillText(rank + '. ', 90, y);

                    // Display username in skin color if available, otherwise white
                    const rankText = rank + '. ';
                    const rankWidth = ctx.measureText(rankText).width;
                    let usernameX = 90 + rankWidth;

                    // Check if skin exists and is not special skin
                    const skinValue = combined[i].skin;

                    if (skinValue && String(skinValue).toUpperCase().trim() !== 'RAINBOW' && String(skinValue).toUpperCase().trim() !== 'HACKER' && String(skinValue).toUpperCase().trim() !== 'SPEED' && String(skinValue).toUpperCase().trim() !== 'NINJA') {
                        // Convert color name to hex code for display
                        const colorNameToHex = {
                            'RED': RED,
                            'ORANGE': ORANGE,
                            'YELLOW': YELLOW,
                            'GREEN': GREEN,
                            'BLUE': BLUE,
                            'PURPLE': PURPLE,
                            'DARK_PURPLE': DARK_PURPLE,
                            'BLACK': BLACK,
                            'GRAY': GRAY,
                            'WHITE': WHITE,
                            'DARKGREEN': DARKGREEN
                        };
                        // Convert to uppercase for case-insensitive matching and trim whitespace
                        const skinUpper = String(skinValue).toUpperCase().trim();
                        // Use color name mapping or fall back to original value (for backwards compatibility with hex codes)
                        const displayColor = colorNameToHex[skinUpper];
                        if (displayColor) {
                            ctx.fillStyle = displayColor;
                        } else {
                            // If not found in mapping, try using as hex code directly
                            ctx.fillStyle = skinValue;
                        }
                        // Ensure regular font for color entries
                        ctx.font = '30px Arial';
                        ctx.textAlign = 'left';
                        ctx.fillText(combined[i].user, usernameX, y);
                    } else if (combined[i].skin && combined[i].skin.toUpperCase() === 'RAINBOW') {
                        // Draw each character in a different rainbow color (skip spaces when cycling)
                        const username = combined[i].user;
                        let colorIndex = 0; // Track color index, only advancing for non-space characters
                        let lastUsedColorIndex = 0; // Track the last color used (for spaces)
                        for (let j = 0; j < username.length; j++) {
                            const char = username[j];
                            // Only advance color index if character is not a space
                            if (char !== ' ') {
                                colorIndex = colorIndex % RAINBOW_COLORS.length;
                                ctx.fillStyle = RAINBOW_COLORS[colorIndex];
                                lastUsedColorIndex = colorIndex; // Remember this color for spaces
                                colorIndex++; // Advance for next non-space character
                            } else {
                                // Spaces use the same color as the last non-space character
                                ctx.fillStyle = RAINBOW_COLORS[lastUsedColorIndex];
                            }
                            ctx.fillText(char, usernameX, y);
                            // Move x position for next character
                            usernameX += ctx.measureText(char).width;
                        }
                        // Reset font after rainbow (in case it was changed)
                        ctx.font = '30px Arial';
                    } else if (combined[i].skin && combined[i].skin.toUpperCase() === 'SPEED') {
                        // Draw username in dark red for speed skin
                        ctx.fillStyle = DARK_RED;
                        ctx.font = '30px Arial'; // Use same font size as regular entries
                        ctx.textAlign = 'left';
                        ctx.fillText(combined[i].user, usernameX, y);
                    } else if (combined[i].skin && combined[i].skin.toUpperCase() === 'HACKER') {
                        // Draw username as black with green neon outline (wider font)
                        const username = combined[i].user;
                        // Set wider font for hacker skin
                        ctx.font = 'bold 30px Arial';
                        // Draw black text
                        ctx.fillStyle = BLACK;
                        ctx.fillText(username, usernameX, y);
                        // Draw green outline (stroke)
                        ctx.strokeStyle = HACKER_GREEN;
                        ctx.lineWidth = 2;
                        ctx.strokeText(username, usernameX, y);
                        usernameX += ctx.measureText(username).width;
                        // Reset font back to normal for other elements
                        ctx.font = '30px Arial';
                    } else if (combined[i].skin && combined[i].skin.toUpperCase() === 'NINJA') {
                        // Draw username with white to dark grey gradient (similar to rainbow but with gradient)
                        const username = combined[i].user;
                        for (let j = 0; j < username.length; j++) {
                            const char = username[j];

                            // Calculate gradient: 0.0 = start (white), 1.0 = end (dark grey)
                            const gradientProgress = username.length > 1 ? j / (username.length - 1) : 0;

                            // Calculate color: start at 255 (white), end at ~128 (dark grey)
                            // Dark grey would be around #808080 or RGB(128, 128, 128)
                            const grayValue = Math.round(255 - (gradientProgress * 127)); // 255 to 128

                            // Convert to hex color
                            const grayHex = grayValue.toString(16).padStart(2, '0');
                            const color = '#' + grayHex + grayHex + grayHex;

                            ctx.fillStyle = color;
                            ctx.font = '30px Arial';
                            ctx.textAlign = 'left';
                            ctx.fillText(char, usernameX, y);

                            // Move x position for next character
                            usernameX += ctx.measureText(char).width;
                        }
                    } else {
                        // Default yellow (no color value)
                        ctx.fillStyle = YELLOW;
                        ctx.font = '30px Arial';
                        ctx.textAlign = 'left';
                        ctx.fillText(combined[i].user, usernameX, y);
                    }

                    // Display speed and score separately, aligned to the right
                    ctx.textAlign = 'right';

                    // Draw score first (rightmost)
                    const scoreText = combined[i].score.toString();
                    ctx.fillStyle = WHITE;
                    ctx.fillText(scoreText, 520, y);

                    // Draw speed with different color and spacing (skip 1x as it's default)
                    if (combined[i].speed !== null && combined[i].speed !== undefined) {
                        let speedNum = combined[i].speed / 30;
                        if (combined[i].speed === 15) speedNum = 0.5;

                        // Skip displaying 1x speed (default)
                        if (speedNum === 1) {
                            // Don't display speed for default 1x
                        } else {
                            const speedText = speedNum + 'x';

                            // Measure score width to position speed correctly
                            const scoreWidth = ctx.measureText(scoreText).width;
                            const spacing = 20; // Space between speed and score

                            // Use red for 4x (matching game multiplier), orange for others
                            if (speedNum === 4) {
                                ctx.fillStyle = RED;
                            } else {
                                ctx.fillStyle = ORANGE;
                            }
                            ctx.fillText(speedText, 520 - scoreWidth - spacing, y);
                        }
                    }

                    ctx.fillStyle = WHITE;
                    ctx.textAlign = 'left';

                    // Reset globalAlpha after drawing this row
                    ctx.globalAlpha = 1.0;

                    y += 40;
                }

                // Draw arrow buttons and page numbers if there are more scores to scroll
                if (combined.length > SCORES_PER_PAGE) {
                    // Calculate current page and total pages
                    const currentPage = Math.floor(scoreScrollIndex / SCORES_PER_PAGE) + 1;
                    const totalPages = Math.ceil(combined.length / SCORES_PER_PAGE);

                    // Draw page numbers (centered below scores)
                    ctx.fillStyle = WHITE;
                    ctx.font = '18px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Page ${currentPage} of ${totalPages}`, CANVAS_WIDTH / 2, 370);

                    // Up arrow (only show if not at top)
                    if (scoreScrollIndex > 0) {
                        upArrowBtn.draw();
                    }

                    // Down arrow (only show if not at bottom)
                    if (scoreScrollIndex < maxScroll) {
                        downArrowBtn.draw();
                    }
                }
            }

            backButton.draw();

            // Display new skin unlock notification in top right
            if (newSkinUnlocked) {
                ctx.fillStyle = BLACK;
                ctx.fillRect(450, 10, 150, 40);
                ctx.fillStyle = GREEN;
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'right';
                ctx.fillText('New Skin Unlock', 590, 35);
            }
        }

        // Update cached values when speed or color changes
        function updateCachedValues() {
            // Update multiplier
            if (speed === 60) cachedMultiplier = 2;
            else if (speed === 90) cachedMultiplier = 3;
            else if (speed === 120) cachedMultiplier = 4;
            else cachedMultiplier = 1;

            // Update food color
            cachedFoodColor = snakeColor === RED ? YELLOW : RED;

            // Stop speed skin shake animation if switching away from speed skin
            if (snakeColor !== SPEED && speedSkinShakeInterval) {
                clearInterval(speedSkinShakeInterval);
                speedSkinShakeInterval = null;
                speedSkinShakeOffsets = [];
            }
            // Note: Speed button shake continues as long as speed skin is unlocked (not dependent on current selection)
        }

        // Start the game
        function startGame() {
            // Stop 4x shake animation when leaving settings
            if (shake4xInterval) {
                clearInterval(shake4xInterval);
                shake4xInterval = null;
                shake4xOffsetX = 0;
                shake4xOffsetY = 0;
            }
            // Stop speed skin shake animation when starting new game
            if (speedSkinShakeInterval) {
                clearInterval(speedSkinShakeInterval);
                speedSkinShakeInterval = null;
                speedSkinShakeOffsets = [];
            }
            currentScreen = 'game';
            score = 0;
            snakeList = [];
            snakeLength = 1;
            // Center the snake on the canvas
            snakeX = CANVAS_WIDTH / 2 - SEGMENT_CENTER_OFFSET;
            snakeY = CANVAS_HEIGHT / 2 - SEGMENT_CENTER_OFFSET;

            // Clear score animations
            scoreAnimations = [];
            snakeXChange = 0;
            snakeYChange = 0;
            direction = 100;

            // Update cached values
            updateCachedValues();

            // Random food position
            foodX = Math.floor(Math.random() * (CANVAS_WIDTH - SEGMENT_SIZE));
            foodY = Math.floor(Math.random() * (CANVAS_HEIGHT - SEGMENT_SIZE));

            // Start game loop using requestAnimationFrame for better Safari performance
            if (gameAnimationFrame) cancelAnimationFrame(gameAnimationFrame);
            lastGameUpdateTime = performance.now();
            gameLoop();
        }

        // Game loop using requestAnimationFrame for consistent performance across browsers
        function gameLoop() {
            const now = performance.now();
            const targetInterval = 1000 / speed; // Target milliseconds between updates
            let elapsed = now - lastGameUpdateTime;

            // Use fixed timestep with catch-up to ensure consistent speed across browsers
            // If we fall behind (Safari timing differences), catch up by running multiple updates
            // This ensures the game runs at the same speed regardless of frame rate differences
            let updateCount = 0;
            const maxUpdates = 10; // Increased cap for better catch-up on Safari

            // Calculate how many updates we should do this frame
            const updatesNeeded = Math.floor(elapsed / targetInterval);
            const actualUpdates = Math.min(updatesNeeded, maxUpdates);

            for (let i = 0; i < actualUpdates; i++) {
                lastGameUpdateTime += targetInterval; // Use fixed step for deterministic timing

                // Update position
                snakeX += snakeXChange;
                snakeY += snakeYChange;

                // Calculate center of snake head
                const headCenterX = snakeX + SEGMENT_CENTER_OFFSET;
                const headCenterY = snakeY + SEGMENT_CENTER_OFFSET;

                // Check wall collision (using center of snake head)
                if (headCenterX >= CANVAS_WIDTH || headCenterX < 0 || headCenterY >= CANVAS_HEIGHT || headCenterY < 0) {
                    gameOver();
                    return;
                }

                // Snake - add new segment
                snakeList.push([snakeX, snakeY]);

                // Update speed skin shake offsets array length if needed
                if (snakeColor === SPEED && speedSkinShakeOffsets.length < snakeList.length) {
                    // Add new shake offset for the new segment
                    speedSkinShakeOffsets.push({ x: 0, y: 0 });
                }

                // Remove old segments efficiently (only if needed)
                if (snakeList.length > snakeLength) {
                    const removeCount = snakeList.length - snakeLength;
                    snakeList.splice(0, removeCount);
                    // Also remove corresponding shake offsets if speed skin is active
                    if (snakeColor === SPEED && speedSkinShakeOffsets.length >= removeCount) {
                        speedSkinShakeOffsets.splice(0, removeCount);
                    }
                }

                // Check self collision
                for (let i = 0; i < snakeList.length - 1; i++) {
                    if (snakeList[i][0] === snakeX && snakeList[i][1] === snakeY) {
                        gameOver();
                        return;
                    }
                }

                // Check food collision (using whole front face of snake head - rectangle overlap)
                // Check if food rectangle overlaps with snake head rectangle
                const foodCollision = (snakeX < foodX + SEGMENT_SIZE && snakeX + SEGMENT_SIZE > foodX &&
                    snakeY < foodY + SEGMENT_SIZE && snakeY + SEGMENT_SIZE > foodY);

                // Check proximity for earlier sound (head center close to food center)
                // Play sound when very close, before full collision
                const foodCenterX = foodX + SEGMENT_CENTER_OFFSET;
                const foodCenterY = foodY + SEGMENT_CENTER_OFFSET;
                const distanceX = Math.abs(headCenterX - foodCenterX);
                const distanceY = Math.abs(headCenterY - foodCenterY);
                const isCloseToFood = distanceX < FOOD_PROXIMITY_THRESHOLD && distanceY < FOOD_PROXIMITY_THRESHOLD;

                // Use cached multiplier and food color (updated when speed/snakeColor changes)
                let multiplier = cachedMultiplier;
                let foodColor = cachedFoodColor;

                if (foodCollision || isCloseToFood) {
                    // Play sound immediately when close or colliding (before any processing)
                    if (!isMuted) {
                        // Switch between two instances to avoid delay from reset
                        if (currentBloopSound === bloopSound) {
                            currentBloopSound = bloopSound2;
                        } else {
                            currentBloopSound = bloopSound;
                        }
                        currentBloopSound.currentTime = 0; // Reset to start
                        currentBloopSound.play().catch(err => {
                            console.error('Error playing bloop.mp3:', err);
                        });
                    }
                }

                if (foodCollision) {
                    // Process food collision
                    const pointsGained = 1 * multiplier;
                    score += pointsGained;

                    // Create score animation at food location
                    const animationX = foodX + SEGMENT_CENTER_OFFSET;
                    const animationY = foodY + SEGMENT_CENTER_OFFSET;
                    scoreAnimations.push({
                        x: animationX,
                        y: animationY,
                        value: '+' + pointsGained,
                        startTime: Date.now(),
                        multiplier: multiplier
                    });

                    foodX = Math.floor(Math.random() * (CANVAS_WIDTH - SEGMENT_SIZE));
                    foodY = Math.floor(Math.random() * (CANVAS_HEIGHT - SEGMENT_SIZE));
                    snakeLength += 2;
                }
            }

            // Always render (even if game state didn't update) for smooth animations
            // Use cached multiplier and food color
            const multiplier = cachedMultiplier;
            const foodColor = cachedFoodColor;

            // Draw
            ctx.fillStyle = BLACK;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Score
            ctx.fillStyle = WHITE;
            ctx.font = '30px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Score: ' + score, 10, 35);

            // Cover notification area with black rectangle, then draw multiplier
            ctx.fillStyle = BLACK;
            ctx.fillRect(450, 10, 150, 40);

            // Multiplier (only the number in orange to match leaderboard speed color)
            ctx.textAlign = 'right';
            const multiplierText = multiplier + 'x';
            const prefixText = 'Multiplier (';
            const suffixText = ')';
            const multiplierWidth = ctx.measureText(multiplierText).width;
            const suffixWidth = ctx.measureText(suffixText).width;

            // Draw "Multiplier (" in white
            ctx.fillStyle = WHITE;
            ctx.fillText(prefixText, 598 - multiplierWidth - suffixWidth, 35);

            // Draw multiplier number in orange (or red if 4x)
            if (multiplier === 4) {
                ctx.fillStyle = RED;
            } else {
                ctx.fillStyle = ORANGE;
            }
            ctx.fillText(multiplierText, 598 - suffixWidth, 35);

            // Draw closing ")" in white
            ctx.fillStyle = WHITE;
            ctx.fillText(suffixText, 598, 35);

            // Food
            ctx.fillStyle = foodColor;
            ctx.fillRect(foodX, foodY, SEGMENT_SIZE, SEGMENT_SIZE);

            // Draw snake
            if (snakeColor === RAINBOW) {
                // Draw each segment with color based on position
                for (let i = 0; i < snakeList.length; i++) {
                    const x = snakeList[i][0];
                    const y = snakeList[i][1];
                    // Use position to determine color - creates smooth gradient across the canvas
                    // Combine x and y for diagonal gradient effect
                    const positionValue = (x + y * 0.7) % (RAINBOW_COLORS.length * 30);
                    const colorIndex = Math.floor(positionValue / 30) % RAINBOW_COLORS.length;
                    ctx.fillStyle = RAINBOW_COLORS[colorIndex];
                    ctx.fillRect(x, y, SEGMENT_SIZE, SEGMENT_SIZE);
                }
            } else if (snakeColor === SPEED) {
                // Draw speed skin in dark red with shake effect (visual only, doesn't affect hitbox)
                ctx.fillStyle = DARK_RED;

                // Initialize shake offsets array if needed
                if (speedSkinShakeOffsets.length !== snakeList.length) {
                    speedSkinShakeOffsets = new Array(snakeList.length).fill(null).map(() => ({ x: 0, y: 0 }));
                }

                // Start shake animation if not already running
                if (!speedSkinShakeInterval) {
                    speedSkinShakeInterval = setInterval(function () {
                        // Update shake offsets for each segment (reduced: random offset between -2 and 2 pixels)
                        for (let i = 0; i < speedSkinShakeOffsets.length; i++) {
                            speedSkinShakeOffsets[i].x = (Math.random() - 0.5) * 4;
                            speedSkinShakeOffsets[i].y = (Math.random() - 0.5) * 4;
                        }
                        // Redraw game screen if still in game
                        if (currentScreen === 'game') {
                            gameLoop();
                        }
                    }, 75); // Update every 75ms for smoother, less aggressive animation
                }

                // Draw each segment with shake offset (visual position only)
                for (let i = 0; i < snakeList.length; i++) {
                    const baseX = snakeList[i][0]; // Actual position (used for collision)
                    const baseY = snakeList[i][1]; // Actual position (used for collision)
                    const shakeX = speedSkinShakeOffsets[i] ? speedSkinShakeOffsets[i].x : 0;
                    const shakeY = speedSkinShakeOffsets[i] ? speedSkinShakeOffsets[i].y : 0;
                    // Draw at visual position (base + shake), but collision uses base position
                    ctx.fillRect(baseX + shakeX, baseY + shakeY, SEGMENT_SIZE, SEGMENT_SIZE);
                }
            } else if (snakeColor === HACKER) {
                // Draw each segment as black with green neon outline on every other segment
                // First block (i=0) has outline, then every other one
                ctx.fillStyle = BLACK;
                for (let i = 0; i < snakeList.length; i++) {
                    const x = snakeList[i][0];
                    const y = snakeList[i][1];
                    ctx.fillRect(x, y, SEGMENT_SIZE, SEGMENT_SIZE);
                    // Draw green outline on every other segment (starting with first)
                    if (i % 2 === 0) {
                        ctx.strokeStyle = HACKER_GREEN;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, SEGMENT_SIZE, SEGMENT_SIZE);
                    }
                }
            } else if (snakeColor === NINJA) {
                // Draw ninja skin: white at head, gradually gets darker, almost black at tail
                // Initially all segments start as white (top gradient color)
                // Head is at the END of snakeList (last index), tail is at the BEGINNING (index 0)
                // So: last index = white (255,255,255), first index = almost black (1,1,1)
                for (let i = 0; i < snakeList.length; i++) {
                    const x = snakeList[i][0];
                    const y = snakeList[i][1];

                    // If snake is very short, keep all segments white (top gradient color)
                    // Once it grows longer, apply the gradient
                    if (snakeList.length <= 1) {
                        ctx.fillStyle = WHITE;
                    } else {
                        // Calculate gradient: 0.0 = tail (dark), 1.0 = head (white)
                        // Head is at the end of the array (last index), tail is at the beginning (index 0)
                        // i=0 is tail (darkest), i=length-1 is head (lightest)
                        const gradientProgress = i / (snakeList.length - 1);

                        // Calculate color: start at 1 (almost black) at tail, end at 255 (white) at head
                        // gradientProgress = 0 at tail (i=0), = 1 at head (i=length-1)
                        // Formula: grayValue = gradientProgress * 254 + 1
                        // When gradientProgress = 0 (tail): grayValue = 1 (almost black)
                        // When gradientProgress = 1 (head): grayValue = 255 (white)
                        const grayValue = Math.round(gradientProgress * 254 + 1); // 1 to 255
                        // Ensure first segment (tail) is exactly 1 (almost black, one value before pure black)
                        const finalGrayValue = i === 0 ? 1 : grayValue;

                        // Convert to hex color
                        const grayHex = finalGrayValue.toString(16).padStart(2, '0');
                        const color = '#' + grayHex + grayHex + grayHex;
                        ctx.fillStyle = color;
                    }

                    ctx.fillRect(x, y, SEGMENT_SIZE, SEGMENT_SIZE);
                }
            } else {
                ctx.fillStyle = snakeColor;
                for (let segment of snakeList) {
                    ctx.fillRect(segment[0], segment[1], SEGMENT_SIZE, SEGMENT_SIZE);
                }
            }

            // Update and draw score animations
            const currentTime = Date.now();
            scoreAnimations = scoreAnimations.filter(anim => {
                const elapsed = currentTime - anim.startTime;
                const progress = elapsed / SCORE_ANIMATION_DURATION;

                if (progress >= 1) {
                    return false; // Animation complete, remove it
                }

                // Calculate position (move up and fade out)
                const offsetY = -progress * SCORE_ANIMATION_DISTANCE;
                const alpha = 1 - progress; // Fade out

                // Draw score animation
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = anim.multiplier === 4 ? RED : ORANGE; // Red for 4x, orange for others
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(anim.value, anim.x, anim.y + offsetY);
                ctx.restore();

                return true; // Keep animation
            });

            // Continue animation loop
            if (currentScreen === 'game') {
                gameAnimationFrame = requestAnimationFrame(gameLoop);
            }
        }

        // Game over
        function gameOver() {
            if (gameAnimationFrame) {
                cancelAnimationFrame(gameAnimationFrame);
                gameAnimationFrame = null;
            }
            // Clear score animations
            scoreAnimations = [];
            // Stop speed skin shake animation when game ends
            if (speedSkinShakeInterval) {
                clearInterval(speedSkinShakeInterval);
                speedSkinShakeInterval = null;
                speedSkinShakeOffsets = [];
            }
            currentScreen = 'gameover';
            usernameInput = '';
            scoreSubmitted = false;

            // Unlock rainbow skin if score >= threshold
            const wasRainbowUnlocked = isRainbowUnlocked();
            if (score >= RAINBOW_UNLOCK_SCORE && !wasRainbowUnlocked) {
                unlockRainbow();
                newSkinUnlocked = true; // Show notification immediately
            }

            // Unlock ninja skin if score > 100 on 3x speed
            const wasNinjaUnlocked = isNinjaUnlocked();
            if (score > NINJA_UNLOCK_SCORE && speed === NINJA_UNLOCK_SPEED && !wasNinjaUnlocked) {
                unlockNinja();
                newSkinUnlocked = true; // Show notification immediately
            }

            drawGameOverScreen();
        }

        // Draw game over screen
        function drawGameOverScreen() {
            ctx.fillStyle = BLACK;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title
            ctx.fillStyle = PURPLE;
            ctx.fillRect(95, 50, 420, 80);
            ctx.fillStyle = WHITE;
            ctx.font = 'bold 72px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Game Over!', 304, 105);

            // Score
            ctx.font = '30px Arial';
            ctx.fillText('Score: ' + score, 304, 180);

            // Username prompt (draw before notification to ensure proper settings)
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = WHITE;
            ctx.fillText('Username (3-20 chars):', 304, 240);

            // Display new skin unlock notification in top right (draw last so it's on top)
            if (newSkinUnlocked) {
                ctx.fillStyle = BLACK;
                ctx.fillRect(450, 10, 150, 40);
                ctx.fillStyle = GREEN;
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'right';
                ctx.fillText('New Skin Unlock', 590, 35);
            }

            // Input box (centered)
            const inputBoxWidth = 230;
            const inputBoxX = (canvas.width - inputBoxWidth) / 2;
            ctx.fillStyle = WHITE;
            ctx.fillRect(inputBoxX, 265, inputBoxWidth, 32);
            ctx.fillStyle = BLACK;
            ctx.font = '20px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(usernameInput, inputBoxX + 5, 285);

            // Show character count
            ctx.fillStyle = WHITE;
            ctx.font = '16px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(`${usernameInput.length}/20`, inputBoxX + inputBoxWidth - 5, 310);

            // Submit button (centered)
            submitButton.color = scoreSubmitted ? DARKGREEN : GREEN;
            submitButton.x = (canvas.width - submitButton.width) / 2;
            submitButton.draw();

            // Show "Submitted! Click for Leaderboard" message if score was submitted
            if (showSubmittedMessage && scoreSubmitted) {
                ctx.fillStyle = GREEN;
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Submitted! Click for Leaderboard', 304, 395);
            }

            // Other buttons
            homeButton.draw();
            retryButton.draw();
        }

        // Validate username before submission
        // Note: Uses loadProfanityWords() and containsProfanity() from api-helpers.js
        function validateUsername(username) {
            username = username.trim();

            if (username.length < 3) {
                return { valid: false, error: 'Username must be at least 3 characters' };
            }

            if (username.length > 20) {
                return { valid: false, error: 'Username must be 20 characters or less' };
            }

            if (!/^[a-zA-Z0-9\s\-_]+$/.test(username)) {
                return { valid: false, error: 'Username can only contain letters, numbers, spaces, hyphens, and underscores' };
            }

            // Check for profanity (synchronous check)
            if (containsProfanity(username)) {
                return { valid: false, error: 'Username contains inappropriate content. Please choose a different username.' };
            }

            return { valid: true, username };
        }

        // Submit score to API
        async function submitScoreToAPI() {
            const validation = validateUsername(usernameInput);

            if (!validation.valid) {
                // Show error message (we'll display it on the game over screen)
                alert(validation.error);
                scoreSubmitted = false; // Re-enable if validation fails
                submitButton.color = GREEN;
                drawGameOverScreen();
                return;
            }

            // Disable submit button while submitting
            submitButton.color = GRAY;
            drawGameOverScreen();

            try {
                const result = await submitScore(validation.username, score, speed, snakeColor);

                // Update local lists with fresh data from server
                if (result.topScores && result.topScores.length > 0) {
                    userList = result.topScores.map(s => s.username);
                    scoreList = result.topScores.map(s => s.score);
                    speedList = result.topScores.map(s => s.speed || null);
                    skinList = result.topScores.map(s => s.skin || null);
                    loadedChunks = 1; // Reset loaded chunks since we got fresh data
                }

                scoreSubmitted = true;
                submitButton.color = DARKGREEN;

                // Store submitted score info for leaderboard jump
                submittedScoreInfo = {
                    score: score,
                    username: validation.username
                };
                showSubmittedMessage = true;

                drawGameOverScreen();
            } catch (error) {
                console.error('Failed to submit score:', error);
                // Show error message
                alert('Failed to submit score: ' + error.message + '\n\nYour score was: ' + score);
                // Re-enable submit button
                submitButton.color = GREEN;
                scoreSubmitted = false;
                showSubmittedMessage = false;
                submittedScoreInfo = null;
                drawGameOverScreen();
            }
        }

        // Start the game when page loads

        init();
    </script>
</body>

</html>